#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <locale.h>
#include "linear.h"
#include "tron.h"


static uint16_t _ccv_base_table[512] = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x100,
  0x200, 0x400, 0x800, 0xc00, 0x1000, 0x1400, 0x1800, 0x1c00, 0x2000, 0x2400, 0x2800, 0x2c00, 0x3000, 0x3400, 0x3800, 0x3c00,
  0x4000, 0x4400, 0x4800, 0x4c00, 0x5000, 0x5400, 0x5800, 0x5c00, 0x6000, 0x6400, 0x6800, 0x6c00, 0x7000, 0x7400, 0x7800, 0x7c00,
  0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
  0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
  0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
  0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
  0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
  0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
  0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8c00, 0x9000, 0x9400, 0x9800, 0x9c00, 0xa000, 0xa400, 0xa800, 0xac00, 0xb000, 0xb400, 0xb800, 0xbc00,
  0xc000, 0xc400, 0xc800, 0xcc00, 0xd000, 0xd400, 0xd800, 0xdc00, 0xe000, 0xe400, 0xe800, 0xec00, 0xf000, 0xf400, 0xf800, 0xfc00,
  0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
  0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
  0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
  0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
  0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
  0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
  0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
};

static uint8_t _ccv_shift_table[512] = {
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0xf,
  0xe, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
  0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xd,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0xf,
  0xe, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
  0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xd,
};

void ccv_float_to_half_precision(float* f, uint16_t* h, size_t len)
{
  int i;
  uint32_t* u = (uint32_t*)f;
  for (i = 0; i < len; i++)
    h[i] = _ccv_base_table[(u[i] >> 23) & 0x1ff] + ((u[i] & 0x007fffff) >> _ccv_shift_table[(u[i] >> 23) & 0x1ff]);
}

static uint32_t _ccv_mantissa_table[2048] = {
  0x0, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34a00000, 0x34c00000, 0x34e00000,
  0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35a00000, 0x35a80000, 0x35b00000, 0x35b80000,
  0x35c00000, 0x35c80000, 0x35d00000, 0x35d80000, 0x35e00000, 0x35e80000, 0x35f00000, 0x35f80000,
  0x36000000, 0x36040000, 0x36080000, 0x360c0000, 0x36100000, 0x36140000, 0x36180000, 0x361c0000,
  0x36200000, 0x36240000, 0x36280000, 0x362c0000, 0x36300000, 0x36340000, 0x36380000, 0x363c0000,
  0x36400000, 0x36440000, 0x36480000, 0x364c0000, 0x36500000, 0x36540000, 0x36580000, 0x365c0000,
  0x36600000, 0x36640000, 0x36680000, 0x366c0000, 0x36700000, 0x36740000, 0x36780000, 0x367c0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368a0000, 0x368c0000, 0x368e0000,
  0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369a0000, 0x369c0000, 0x369e0000,
  0x36a00000, 0x36a20000, 0x36a40000, 0x36a60000, 0x36a80000, 0x36aa0000, 0x36ac0000, 0x36ae0000,
  0x36b00000, 0x36b20000, 0x36b40000, 0x36b60000, 0x36b80000, 0x36ba0000, 0x36bc0000, 0x36be0000,
  0x36c00000, 0x36c20000, 0x36c40000, 0x36c60000, 0x36c80000, 0x36ca0000, 0x36cc0000, 0x36ce0000,
  0x36d00000, 0x36d20000, 0x36d40000, 0x36d60000, 0x36d80000, 0x36da0000, 0x36dc0000, 0x36de0000,
  0x36e00000, 0x36e20000, 0x36e40000, 0x36e60000, 0x36e80000, 0x36ea0000, 0x36ec0000, 0x36ee0000,
  0x36f00000, 0x36f20000, 0x36f40000, 0x36f60000, 0x36f80000, 0x36fa0000, 0x36fc0000, 0x36fe0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000,
  0x37080000, 0x37090000, 0x370a0000, 0x370b0000, 0x370c0000, 0x370d0000, 0x370e0000, 0x370f0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000,
  0x37180000, 0x37190000, 0x371a0000, 0x371b0000, 0x371c0000, 0x371d0000, 0x371e0000, 0x371f0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000,
  0x37280000, 0x37290000, 0x372a0000, 0x372b0000, 0x372c0000, 0x372d0000, 0x372e0000, 0x372f0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000,
  0x37380000, 0x37390000, 0x373a0000, 0x373b0000, 0x373c0000, 0x373d0000, 0x373e0000, 0x373f0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000,
  0x37480000, 0x37490000, 0x374a0000, 0x374b0000, 0x374c0000, 0x374d0000, 0x374e0000, 0x374f0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000,
  0x37580000, 0x37590000, 0x375a0000, 0x375b0000, 0x375c0000, 0x375d0000, 0x375e0000, 0x375f0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000,
  0x37680000, 0x37690000, 0x376a0000, 0x376b0000, 0x376c0000, 0x376d0000, 0x376e0000, 0x376f0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000,
  0x37780000, 0x37790000, 0x377a0000, 0x377b0000, 0x377c0000, 0x377d0000, 0x377e0000, 0x377f0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000,
  0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378a0000, 0x378a8000, 0x378b0000, 0x378b8000,
  0x378c0000, 0x378c8000, 0x378d0000, 0x378d8000, 0x378e0000, 0x378e8000, 0x378f0000, 0x378f8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000,
  0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379a0000, 0x379a8000, 0x379b0000, 0x379b8000,
  0x379c0000, 0x379c8000, 0x379d0000, 0x379d8000, 0x379e0000, 0x379e8000, 0x379f0000, 0x379f8000,
  0x37a00000, 0x37a08000, 0x37a10000, 0x37a18000, 0x37a20000, 0x37a28000, 0x37a30000, 0x37a38000,
  0x37a40000, 0x37a48000, 0x37a50000, 0x37a58000, 0x37a60000, 0x37a68000, 0x37a70000, 0x37a78000,
  0x37a80000, 0x37a88000, 0x37a90000, 0x37a98000, 0x37aa0000, 0x37aa8000, 0x37ab0000, 0x37ab8000,
  0x37ac0000, 0x37ac8000, 0x37ad0000, 0x37ad8000, 0x37ae0000, 0x37ae8000, 0x37af0000, 0x37af8000,
  0x37b00000, 0x37b08000, 0x37b10000, 0x37b18000, 0x37b20000, 0x37b28000, 0x37b30000, 0x37b38000,
  0x37b40000, 0x37b48000, 0x37b50000, 0x37b58000, 0x37b60000, 0x37b68000, 0x37b70000, 0x37b78000,
  0x37b80000, 0x37b88000, 0x37b90000, 0x37b98000, 0x37ba0000, 0x37ba8000, 0x37bb0000, 0x37bb8000,
  0x37bc0000, 0x37bc8000, 0x37bd0000, 0x37bd8000, 0x37be0000, 0x37be8000, 0x37bf0000, 0x37bf8000,
  0x37c00000, 0x37c08000, 0x37c10000, 0x37c18000, 0x37c20000, 0x37c28000, 0x37c30000, 0x37c38000,
  0x37c40000, 0x37c48000, 0x37c50000, 0x37c58000, 0x37c60000, 0x37c68000, 0x37c70000, 0x37c78000,
  0x37c80000, 0x37c88000, 0x37c90000, 0x37c98000, 0x37ca0000, 0x37ca8000, 0x37cb0000, 0x37cb8000,
  0x37cc0000, 0x37cc8000, 0x37cd0000, 0x37cd8000, 0x37ce0000, 0x37ce8000, 0x37cf0000, 0x37cf8000,
  0x37d00000, 0x37d08000, 0x37d10000, 0x37d18000, 0x37d20000, 0x37d28000, 0x37d30000, 0x37d38000,
  0x37d40000, 0x37d48000, 0x37d50000, 0x37d58000, 0x37d60000, 0x37d68000, 0x37d70000, 0x37d78000,
  0x37d80000, 0x37d88000, 0x37d90000, 0x37d98000, 0x37da0000, 0x37da8000, 0x37db0000, 0x37db8000,
  0x37dc0000, 0x37dc8000, 0x37dd0000, 0x37dd8000, 0x37de0000, 0x37de8000, 0x37df0000, 0x37df8000,
  0x37e00000, 0x37e08000, 0x37e10000, 0x37e18000, 0x37e20000, 0x37e28000, 0x37e30000, 0x37e38000,
  0x37e40000, 0x37e48000, 0x37e50000, 0x37e58000, 0x37e60000, 0x37e68000, 0x37e70000, 0x37e78000,
  0x37e80000, 0x37e88000, 0x37e90000, 0x37e98000, 0x37ea0000, 0x37ea8000, 0x37eb0000, 0x37eb8000,
  0x37ec0000, 0x37ec8000, 0x37ed0000, 0x37ed8000, 0x37ee0000, 0x37ee8000, 0x37ef0000, 0x37ef8000,
  0x37f00000, 0x37f08000, 0x37f10000, 0x37f18000, 0x37f20000, 0x37f28000, 0x37f30000, 0x37f38000,
  0x37f40000, 0x37f48000, 0x37f50000, 0x37f58000, 0x37f60000, 0x37f68000, 0x37f70000, 0x37f78000,
  0x37f80000, 0x37f88000, 0x37f90000, 0x37f98000, 0x37fa0000, 0x37fa8000, 0x37fb0000, 0x37fb8000,
  0x37fc0000, 0x37fc8000, 0x37fd0000, 0x37fd8000, 0x37fe0000, 0x37fe8000, 0x37ff0000, 0x37ff8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800c000, 0x38010000, 0x38014000, 0x38018000, 0x3801c000,
  0x38020000, 0x38024000, 0x38028000, 0x3802c000, 0x38030000, 0x38034000, 0x38038000, 0x3803c000,
  0x38040000, 0x38044000, 0x38048000, 0x3804c000, 0x38050000, 0x38054000, 0x38058000, 0x3805c000,
  0x38060000, 0x38064000, 0x38068000, 0x3806c000, 0x38070000, 0x38074000, 0x38078000, 0x3807c000,
  0x38080000, 0x38084000, 0x38088000, 0x3808c000, 0x38090000, 0x38094000, 0x38098000, 0x3809c000,
  0x380a0000, 0x380a4000, 0x380a8000, 0x380ac000, 0x380b0000, 0x380b4000, 0x380b8000, 0x380bc000,
  0x380c0000, 0x380c4000, 0x380c8000, 0x380cc000, 0x380d0000, 0x380d4000, 0x380d8000, 0x380dc000,
  0x380e0000, 0x380e4000, 0x380e8000, 0x380ec000, 0x380f0000, 0x380f4000, 0x380f8000, 0x380fc000,
  0x38100000, 0x38104000, 0x38108000, 0x3810c000, 0x38110000, 0x38114000, 0x38118000, 0x3811c000,
  0x38120000, 0x38124000, 0x38128000, 0x3812c000, 0x38130000, 0x38134000, 0x38138000, 0x3813c000,
  0x38140000, 0x38144000, 0x38148000, 0x3814c000, 0x38150000, 0x38154000, 0x38158000, 0x3815c000,
  0x38160000, 0x38164000, 0x38168000, 0x3816c000, 0x38170000, 0x38174000, 0x38178000, 0x3817c000,
  0x38180000, 0x38184000, 0x38188000, 0x3818c000, 0x38190000, 0x38194000, 0x38198000, 0x3819c000,
  0x381a0000, 0x381a4000, 0x381a8000, 0x381ac000, 0x381b0000, 0x381b4000, 0x381b8000, 0x381bc000,
  0x381c0000, 0x381c4000, 0x381c8000, 0x381cc000, 0x381d0000, 0x381d4000, 0x381d8000, 0x381dc000,
  0x381e0000, 0x381e4000, 0x381e8000, 0x381ec000, 0x381f0000, 0x381f4000, 0x381f8000, 0x381fc000,
  0x38200000, 0x38204000, 0x38208000, 0x3820c000, 0x38210000, 0x38214000, 0x38218000, 0x3821c000,
  0x38220000, 0x38224000, 0x38228000, 0x3822c000, 0x38230000, 0x38234000, 0x38238000, 0x3823c000,
  0x38240000, 0x38244000, 0x38248000, 0x3824c000, 0x38250000, 0x38254000, 0x38258000, 0x3825c000,
  0x38260000, 0x38264000, 0x38268000, 0x3826c000, 0x38270000, 0x38274000, 0x38278000, 0x3827c000,
  0x38280000, 0x38284000, 0x38288000, 0x3828c000, 0x38290000, 0x38294000, 0x38298000, 0x3829c000,
  0x382a0000, 0x382a4000, 0x382a8000, 0x382ac000, 0x382b0000, 0x382b4000, 0x382b8000, 0x382bc000,
  0x382c0000, 0x382c4000, 0x382c8000, 0x382cc000, 0x382d0000, 0x382d4000, 0x382d8000, 0x382dc000,
  0x382e0000, 0x382e4000, 0x382e8000, 0x382ec000, 0x382f0000, 0x382f4000, 0x382f8000, 0x382fc000,
  0x38300000, 0x38304000, 0x38308000, 0x3830c000, 0x38310000, 0x38314000, 0x38318000, 0x3831c000,
  0x38320000, 0x38324000, 0x38328000, 0x3832c000, 0x38330000, 0x38334000, 0x38338000, 0x3833c000,
  0x38340000, 0x38344000, 0x38348000, 0x3834c000, 0x38350000, 0x38354000, 0x38358000, 0x3835c000,
  0x38360000, 0x38364000, 0x38368000, 0x3836c000, 0x38370000, 0x38374000, 0x38378000, 0x3837c000,
  0x38380000, 0x38384000, 0x38388000, 0x3838c000, 0x38390000, 0x38394000, 0x38398000, 0x3839c000,
  0x383a0000, 0x383a4000, 0x383a8000, 0x383ac000, 0x383b0000, 0x383b4000, 0x383b8000, 0x383bc000,
  0x383c0000, 0x383c4000, 0x383c8000, 0x383cc000, 0x383d0000, 0x383d4000, 0x383d8000, 0x383dc000,
  0x383e0000, 0x383e4000, 0x383e8000, 0x383ec000, 0x383f0000, 0x383f4000, 0x383f8000, 0x383fc000,
  0x38400000, 0x38404000, 0x38408000, 0x3840c000, 0x38410000, 0x38414000, 0x38418000, 0x3841c000,
  0x38420000, 0x38424000, 0x38428000, 0x3842c000, 0x38430000, 0x38434000, 0x38438000, 0x3843c000,
  0x38440000, 0x38444000, 0x38448000, 0x3844c000, 0x38450000, 0x38454000, 0x38458000, 0x3845c000,
  0x38460000, 0x38464000, 0x38468000, 0x3846c000, 0x38470000, 0x38474000, 0x38478000, 0x3847c000,
  0x38480000, 0x38484000, 0x38488000, 0x3848c000, 0x38490000, 0x38494000, 0x38498000, 0x3849c000,
  0x384a0000, 0x384a4000, 0x384a8000, 0x384ac000, 0x384b0000, 0x384b4000, 0x384b8000, 0x384bc000,
  0x384c0000, 0x384c4000, 0x384c8000, 0x384cc000, 0x384d0000, 0x384d4000, 0x384d8000, 0x384dc000,
  0x384e0000, 0x384e4000, 0x384e8000, 0x384ec000, 0x384f0000, 0x384f4000, 0x384f8000, 0x384fc000,
  0x38500000, 0x38504000, 0x38508000, 0x3850c000, 0x38510000, 0x38514000, 0x38518000, 0x3851c000,
  0x38520000, 0x38524000, 0x38528000, 0x3852c000, 0x38530000, 0x38534000, 0x38538000, 0x3853c000,
  0x38540000, 0x38544000, 0x38548000, 0x3854c000, 0x38550000, 0x38554000, 0x38558000, 0x3855c000,
  0x38560000, 0x38564000, 0x38568000, 0x3856c000, 0x38570000, 0x38574000, 0x38578000, 0x3857c000,
  0x38580000, 0x38584000, 0x38588000, 0x3858c000, 0x38590000, 0x38594000, 0x38598000, 0x3859c000,
  0x385a0000, 0x385a4000, 0x385a8000, 0x385ac000, 0x385b0000, 0x385b4000, 0x385b8000, 0x385bc000,
  0x385c0000, 0x385c4000, 0x385c8000, 0x385cc000, 0x385d0000, 0x385d4000, 0x385d8000, 0x385dc000,
  0x385e0000, 0x385e4000, 0x385e8000, 0x385ec000, 0x385f0000, 0x385f4000, 0x385f8000, 0x385fc000,
  0x38600000, 0x38604000, 0x38608000, 0x3860c000, 0x38610000, 0x38614000, 0x38618000, 0x3861c000,
  0x38620000, 0x38624000, 0x38628000, 0x3862c000, 0x38630000, 0x38634000, 0x38638000, 0x3863c000,
  0x38640000, 0x38644000, 0x38648000, 0x3864c000, 0x38650000, 0x38654000, 0x38658000, 0x3865c000,
  0x38660000, 0x38664000, 0x38668000, 0x3866c000, 0x38670000, 0x38674000, 0x38678000, 0x3867c000,
  0x38680000, 0x38684000, 0x38688000, 0x3868c000, 0x38690000, 0x38694000, 0x38698000, 0x3869c000,
  0x386a0000, 0x386a4000, 0x386a8000, 0x386ac000, 0x386b0000, 0x386b4000, 0x386b8000, 0x386bc000,
  0x386c0000, 0x386c4000, 0x386c8000, 0x386cc000, 0x386d0000, 0x386d4000, 0x386d8000, 0x386dc000,
  0x386e0000, 0x386e4000, 0x386e8000, 0x386ec000, 0x386f0000, 0x386f4000, 0x386f8000, 0x386fc000,
  0x38700000, 0x38704000, 0x38708000, 0x3870c000, 0x38710000, 0x38714000, 0x38718000, 0x3871c000,
  0x38720000, 0x38724000, 0x38728000, 0x3872c000, 0x38730000, 0x38734000, 0x38738000, 0x3873c000,
  0x38740000, 0x38744000, 0x38748000, 0x3874c000, 0x38750000, 0x38754000, 0x38758000, 0x3875c000,
  0x38760000, 0x38764000, 0x38768000, 0x3876c000, 0x38770000, 0x38774000, 0x38778000, 0x3877c000,
  0x38780000, 0x38784000, 0x38788000, 0x3878c000, 0x38790000, 0x38794000, 0x38798000, 0x3879c000,
  0x387a0000, 0x387a4000, 0x387a8000, 0x387ac000, 0x387b0000, 0x387b4000, 0x387b8000, 0x387bc000,
  0x387c0000, 0x387c4000, 0x387c8000, 0x387cc000, 0x387d0000, 0x387d4000, 0x387d8000, 0x387dc000,
  0x387e0000, 0x387e4000, 0x387e8000, 0x387ec000, 0x387f0000, 0x387f4000, 0x387f8000, 0x387fc000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800a000, 0x3800c000, 0x3800e000,
  0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801a000, 0x3801c000, 0x3801e000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802a000, 0x3802c000, 0x3802e000,
  0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803a000, 0x3803c000, 0x3803e000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804a000, 0x3804c000, 0x3804e000,
  0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805a000, 0x3805c000, 0x3805e000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806a000, 0x3806c000, 0x3806e000,
  0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807a000, 0x3807c000, 0x3807e000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808a000, 0x3808c000, 0x3808e000,
  0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809a000, 0x3809c000, 0x3809e000,
  0x380a0000, 0x380a2000, 0x380a4000, 0x380a6000, 0x380a8000, 0x380aa000, 0x380ac000, 0x380ae000,
  0x380b0000, 0x380b2000, 0x380b4000, 0x380b6000, 0x380b8000, 0x380ba000, 0x380bc000, 0x380be000,
  0x380c0000, 0x380c2000, 0x380c4000, 0x380c6000, 0x380c8000, 0x380ca000, 0x380cc000, 0x380ce000,
  0x380d0000, 0x380d2000, 0x380d4000, 0x380d6000, 0x380d8000, 0x380da000, 0x380dc000, 0x380de000,
  0x380e0000, 0x380e2000, 0x380e4000, 0x380e6000, 0x380e8000, 0x380ea000, 0x380ec000, 0x380ee000,
  0x380f0000, 0x380f2000, 0x380f4000, 0x380f6000, 0x380f8000, 0x380fa000, 0x380fc000, 0x380fe000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810a000, 0x3810c000, 0x3810e000,
  0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811a000, 0x3811c000, 0x3811e000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812a000, 0x3812c000, 0x3812e000,
  0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813a000, 0x3813c000, 0x3813e000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814a000, 0x3814c000, 0x3814e000,
  0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815a000, 0x3815c000, 0x3815e000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816a000, 0x3816c000, 0x3816e000,
  0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817a000, 0x3817c000, 0x3817e000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818a000, 0x3818c000, 0x3818e000,
  0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819a000, 0x3819c000, 0x3819e000,
  0x381a0000, 0x381a2000, 0x381a4000, 0x381a6000, 0x381a8000, 0x381aa000, 0x381ac000, 0x381ae000,
  0x381b0000, 0x381b2000, 0x381b4000, 0x381b6000, 0x381b8000, 0x381ba000, 0x381bc000, 0x381be000,
  0x381c0000, 0x381c2000, 0x381c4000, 0x381c6000, 0x381c8000, 0x381ca000, 0x381cc000, 0x381ce000,
  0x381d0000, 0x381d2000, 0x381d4000, 0x381d6000, 0x381d8000, 0x381da000, 0x381dc000, 0x381de000,
  0x381e0000, 0x381e2000, 0x381e4000, 0x381e6000, 0x381e8000, 0x381ea000, 0x381ec000, 0x381ee000,
  0x381f0000, 0x381f2000, 0x381f4000, 0x381f6000, 0x381f8000, 0x381fa000, 0x381fc000, 0x381fe000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820a000, 0x3820c000, 0x3820e000,
  0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821a000, 0x3821c000, 0x3821e000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822a000, 0x3822c000, 0x3822e000,
  0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823a000, 0x3823c000, 0x3823e000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824a000, 0x3824c000, 0x3824e000,
  0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825a000, 0x3825c000, 0x3825e000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826a000, 0x3826c000, 0x3826e000,
  0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827a000, 0x3827c000, 0x3827e000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828a000, 0x3828c000, 0x3828e000,
  0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829a000, 0x3829c000, 0x3829e000,
  0x382a0000, 0x382a2000, 0x382a4000, 0x382a6000, 0x382a8000, 0x382aa000, 0x382ac000, 0x382ae000,
  0x382b0000, 0x382b2000, 0x382b4000, 0x382b6000, 0x382b8000, 0x382ba000, 0x382bc000, 0x382be000,
  0x382c0000, 0x382c2000, 0x382c4000, 0x382c6000, 0x382c8000, 0x382ca000, 0x382cc000, 0x382ce000,
  0x382d0000, 0x382d2000, 0x382d4000, 0x382d6000, 0x382d8000, 0x382da000, 0x382dc000, 0x382de000,
  0x382e0000, 0x382e2000, 0x382e4000, 0x382e6000, 0x382e8000, 0x382ea000, 0x382ec000, 0x382ee000,
  0x382f0000, 0x382f2000, 0x382f4000, 0x382f6000, 0x382f8000, 0x382fa000, 0x382fc000, 0x382fe000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830a000, 0x3830c000, 0x3830e000,
  0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831a000, 0x3831c000, 0x3831e000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832a000, 0x3832c000, 0x3832e000,
  0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833a000, 0x3833c000, 0x3833e000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834a000, 0x3834c000, 0x3834e000,
  0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835a000, 0x3835c000, 0x3835e000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836a000, 0x3836c000, 0x3836e000,
  0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837a000, 0x3837c000, 0x3837e000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838a000, 0x3838c000, 0x3838e000,
  0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839a000, 0x3839c000, 0x3839e000,
  0x383a0000, 0x383a2000, 0x383a4000, 0x383a6000, 0x383a8000, 0x383aa000, 0x383ac000, 0x383ae000,
  0x383b0000, 0x383b2000, 0x383b4000, 0x383b6000, 0x383b8000, 0x383ba000, 0x383bc000, 0x383be000,
  0x383c0000, 0x383c2000, 0x383c4000, 0x383c6000, 0x383c8000, 0x383ca000, 0x383cc000, 0x383ce000,
  0x383d0000, 0x383d2000, 0x383d4000, 0x383d6000, 0x383d8000, 0x383da000, 0x383dc000, 0x383de000,
  0x383e0000, 0x383e2000, 0x383e4000, 0x383e6000, 0x383e8000, 0x383ea000, 0x383ec000, 0x383ee000,
  0x383f0000, 0x383f2000, 0x383f4000, 0x383f6000, 0x383f8000, 0x383fa000, 0x383fc000, 0x383fe000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840a000, 0x3840c000, 0x3840e000,
  0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841a000, 0x3841c000, 0x3841e000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842a000, 0x3842c000, 0x3842e000,
  0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843a000, 0x3843c000, 0x3843e000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844a000, 0x3844c000, 0x3844e000,
  0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845a000, 0x3845c000, 0x3845e000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846a000, 0x3846c000, 0x3846e000,
  0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847a000, 0x3847c000, 0x3847e000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848a000, 0x3848c000, 0x3848e000,
  0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849a000, 0x3849c000, 0x3849e000,
  0x384a0000, 0x384a2000, 0x384a4000, 0x384a6000, 0x384a8000, 0x384aa000, 0x384ac000, 0x384ae000,
  0x384b0000, 0x384b2000, 0x384b4000, 0x384b6000, 0x384b8000, 0x384ba000, 0x384bc000, 0x384be000,
  0x384c0000, 0x384c2000, 0x384c4000, 0x384c6000, 0x384c8000, 0x384ca000, 0x384cc000, 0x384ce000,
  0x384d0000, 0x384d2000, 0x384d4000, 0x384d6000, 0x384d8000, 0x384da000, 0x384dc000, 0x384de000,
  0x384e0000, 0x384e2000, 0x384e4000, 0x384e6000, 0x384e8000, 0x384ea000, 0x384ec000, 0x384ee000,
  0x384f0000, 0x384f2000, 0x384f4000, 0x384f6000, 0x384f8000, 0x384fa000, 0x384fc000, 0x384fe000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850a000, 0x3850c000, 0x3850e000,
  0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851a000, 0x3851c000, 0x3851e000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852a000, 0x3852c000, 0x3852e000,
  0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853a000, 0x3853c000, 0x3853e000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854a000, 0x3854c000, 0x3854e000,
  0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855a000, 0x3855c000, 0x3855e000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856a000, 0x3856c000, 0x3856e000,
  0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857a000, 0x3857c000, 0x3857e000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858a000, 0x3858c000, 0x3858e000,
  0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859a000, 0x3859c000, 0x3859e000,
  0x385a0000, 0x385a2000, 0x385a4000, 0x385a6000, 0x385a8000, 0x385aa000, 0x385ac000, 0x385ae000,
  0x385b0000, 0x385b2000, 0x385b4000, 0x385b6000, 0x385b8000, 0x385ba000, 0x385bc000, 0x385be000,
  0x385c0000, 0x385c2000, 0x385c4000, 0x385c6000, 0x385c8000, 0x385ca000, 0x385cc000, 0x385ce000,
  0x385d0000, 0x385d2000, 0x385d4000, 0x385d6000, 0x385d8000, 0x385da000, 0x385dc000, 0x385de000,
  0x385e0000, 0x385e2000, 0x385e4000, 0x385e6000, 0x385e8000, 0x385ea000, 0x385ec000, 0x385ee000,
  0x385f0000, 0x385f2000, 0x385f4000, 0x385f6000, 0x385f8000, 0x385fa000, 0x385fc000, 0x385fe000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860a000, 0x3860c000, 0x3860e000,
  0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861a000, 0x3861c000, 0x3861e000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862a000, 0x3862c000, 0x3862e000,
  0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863a000, 0x3863c000, 0x3863e000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864a000, 0x3864c000, 0x3864e000,
  0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865a000, 0x3865c000, 0x3865e000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866a000, 0x3866c000, 0x3866e000,
  0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867a000, 0x3867c000, 0x3867e000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868a000, 0x3868c000, 0x3868e000,
  0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869a000, 0x3869c000, 0x3869e000,
  0x386a0000, 0x386a2000, 0x386a4000, 0x386a6000, 0x386a8000, 0x386aa000, 0x386ac000, 0x386ae000,
  0x386b0000, 0x386b2000, 0x386b4000, 0x386b6000, 0x386b8000, 0x386ba000, 0x386bc000, 0x386be000,
  0x386c0000, 0x386c2000, 0x386c4000, 0x386c6000, 0x386c8000, 0x386ca000, 0x386cc000, 0x386ce000,
  0x386d0000, 0x386d2000, 0x386d4000, 0x386d6000, 0x386d8000, 0x386da000, 0x386dc000, 0x386de000,
  0x386e0000, 0x386e2000, 0x386e4000, 0x386e6000, 0x386e8000, 0x386ea000, 0x386ec000, 0x386ee000,
  0x386f0000, 0x386f2000, 0x386f4000, 0x386f6000, 0x386f8000, 0x386fa000, 0x386fc000, 0x386fe000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870a000, 0x3870c000, 0x3870e000,
  0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871a000, 0x3871c000, 0x3871e000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872a000, 0x3872c000, 0x3872e000,
  0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873a000, 0x3873c000, 0x3873e000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874a000, 0x3874c000, 0x3874e000,
  0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875a000, 0x3875c000, 0x3875e000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876a000, 0x3876c000, 0x3876e000,
  0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877a000, 0x3877c000, 0x3877e000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878a000, 0x3878c000, 0x3878e000,
  0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879a000, 0x3879c000, 0x3879e000,
  0x387a0000, 0x387a2000, 0x387a4000, 0x387a6000, 0x387a8000, 0x387aa000, 0x387ac000, 0x387ae000,
  0x387b0000, 0x387b2000, 0x387b4000, 0x387b6000, 0x387b8000, 0x387ba000, 0x387bc000, 0x387be000,
  0x387c0000, 0x387c2000, 0x387c4000, 0x387c6000, 0x387c8000, 0x387ca000, 0x387cc000, 0x387ce000,
  0x387d0000, 0x387d2000, 0x387d4000, 0x387d6000, 0x387d8000, 0x387da000, 0x387dc000, 0x387de000,
  0x387e0000, 0x387e2000, 0x387e4000, 0x387e6000, 0x387e8000, 0x387ea000, 0x387ec000, 0x387ee000,
  0x387f0000, 0x387f2000, 0x387f4000, 0x387f6000, 0x387f8000, 0x387fa000, 0x387fc000, 0x387fe000,
};

static uint32_t _ccv_exponent_table[64] = {
  0x0, 0x800000, 0x1000000, 0x1800000, 0x2000000, 0x2800000, 0x3000000, 0x3800000,
  0x4000000, 0x4800000, 0x5000000, 0x5800000, 0x6000000, 0x6800000, 0x7000000, 0x7800000,
  0x8000000, 0x8800000, 0x9000000, 0x9800000, 0xa000000, 0xa800000, 0xb000000, 0xb800000,
  0xc000000, 0xc800000, 0xd000000, 0xd800000, 0xe000000, 0xe800000, 0xf000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000,
  0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8a000000, 0x8a800000, 0x8b000000, 0x8b800000,
  0x8c000000, 0x8c800000, 0x8d000000, 0x8d800000, 0x8e000000, 0x8e800000, 0x8f000000, 0xc7800000,
};

static uint16_t _ccv_offset_table[64] = {
  0x0, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x0, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
};

void ccv_half_precision_to_float(uint16_t* h, float* f, size_t len)
{
  int i;
  uint32_t* u = (uint32_t*)f;
  for (i = 0; i < len; i++)
    u[i] = _ccv_mantissa_table[_ccv_offset_table[h[i] >> 10] + (h[i] & 0x3ff)] + _ccv_exponent_table[h[i] >> 10];
}


typedef signed char schar;
template <class T> static inline void swap(T& x, T& y) { T t=x; x=y; y=t; }
#ifndef min
template <class T> static inline T min(T x,T y) { return (x<y)?x:y; }
#endif
#ifndef max
template <class T> static inline T max(T x,T y) { return (x>y)?x:y; }
#endif
template <class S, class T> static inline void clone(T*& dst, S* src, int n)
{
    dst = new T[n];
    memcpy((void *)dst,(void *)src,sizeof(T)*n);
}
#define Malloc(type,n) (type *)malloc((n)*sizeof(type))
#define INF HUGE_VAL

static void print_string_stdout(const char *s)
{
    fputs(s,stdout);
    fflush(stdout);
}

static void (*liblinear_print_string) (const char *) = &print_string_stdout;

#if 1
static void info(const char *fmt,...)
{
    char buf[BUFSIZ];
    va_list ap;
    va_start(ap,fmt);
    vsprintf(buf,fmt,ap);
    va_end(ap);
    (*liblinear_print_string)(buf);
}
#else
static void info(const char *fmt,...) {}
#endif

class l2r_lr_fun: public function
{
public:
    l2r_lr_fun(const problem *prob, double *C);
    ~l2r_lr_fun();
    
    double fun(double *w);
    void grad(double *w, double *g);
    void Hv(double *s, double *Hs);
    
    int get_nr_variable(void);
    
private:
    void Xv(double *v, double *Xv);
    void XTv(double *v, double *XTv);
    
    double *C;
    double *z;
    double *D;
    const problem *prob;
};

l2r_lr_fun::l2r_lr_fun(const problem *prob, double *C)
{
    int l=prob->l;
    
    this->prob = prob;
    
    z = new double[l];
    D = new double[l];
    this->C = C;
}

l2r_lr_fun::~l2r_lr_fun()
{
    delete[] z;
    delete[] D;
}


double l2r_lr_fun::fun(double *w)
{
    int i;
    double f=0;
    double *y=prob->y;
    int l=prob->l;
    int w_size=get_nr_variable();
    
    Xv(w, z);
    
    for(i=0;i<w_size;i++)
        f += w[i]*w[i];
    f /= 2.0;
    for(i=0;i<l;i++)
    {
        double yz = y[i]*z[i];
        if (yz >= 0)
            f += C[i]*log(1 + exp(-yz));
        else
            f += C[i]*(-yz+log(1 + exp(yz)));
    }
    
    return(f);
}

void l2r_lr_fun::grad(double *w, double *g)
{
    int i;
    double *y=prob->y;
    int l=prob->l;
    int w_size=get_nr_variable();
    
    for(i=0;i<l;i++)
    {
        z[i] = 1/(1 + exp(-y[i]*z[i]));
        D[i] = z[i]*(1-z[i]);
        z[i] = C[i]*(z[i]-1)*y[i];
    }
    XTv(z, g);
    
    for(i=0;i<w_size;i++)
        g[i] = w[i] + g[i];
}

int l2r_lr_fun::get_nr_variable(void)
{
    return prob->n;
}

void l2r_lr_fun::Hv(double *s, double *Hs)
{
    int i;
    int l=prob->l;
    int w_size=get_nr_variable();
    double *wa = new double[l];
    
    Xv(s, wa);
    for(i=0;i<l;i++)
        wa[i] = C[i]*D[i]*wa[i];
    
    XTv(wa, Hs);
    for(i=0;i<w_size;i++)
        Hs[i] = s[i] + Hs[i];
    delete[] wa;
}

void l2r_lr_fun::Xv(double *v, double *Xv)
{
    int i;
    int l=prob->l;
    feature_node **x=prob->x;
    
    for(i=0;i<l;i++)
    {
        feature_node *s=x[i];
        Xv[i]=0;
        while(s->index!=-1)
        {
            Xv[i]+=v[s->index-1]*s->value;
            s++;
        }
    }
}

void l2r_lr_fun::XTv(double *v, double *XTv)
{
    int i;
    int l=prob->l;
    int w_size=get_nr_variable();
    feature_node **x=prob->x;
    
    for(i=0;i<w_size;i++)
        XTv[i]=0;
    for(i=0;i<l;i++)
    {
        feature_node *s=x[i];
        while(s->index!=-1)
        {
            XTv[s->index-1]+=v[i]*s->value;
            s++;
        }
    }
}

class l2r_l2_svc_fun: public function
{
public:
    l2r_l2_svc_fun(const problem *prob, double *C);
    ~l2r_l2_svc_fun();
    
    double fun(double *w);
    void grad(double *w, double *g);
    void Hv(double *s, double *Hs);
    
    int get_nr_variable(void);
    
protected:
    void Xv(double *v, double *Xv);
    void subXv(double *v, double *Xv);
    void subXTv(double *v, double *XTv);
    
    double *C;
    double *z;
    double *D;
    int *I;
    int sizeI;
    const problem *prob;
};

l2r_l2_svc_fun::l2r_l2_svc_fun(const problem *prob, double *C)
{
    int l=prob->l;
    
    this->prob = prob;
    
    z = new double[l];
    D = new double[l];
    I = new int[l];
    this->C = C;
}

l2r_l2_svc_fun::~l2r_l2_svc_fun()
{
    delete[] z;
    delete[] D;
    delete[] I;
}

double l2r_l2_svc_fun::fun(double *w)
{
    int i;
    double f=0;
    double *y=prob->y;
    int l=prob->l;
    int w_size=get_nr_variable();
    
    Xv(w, z);
    
    for(i=0;i<w_size;i++)
        f += w[i]*w[i];
    f /= 2.0;
    for(i=0;i<l;i++)
    {
        z[i] = y[i]*z[i];
        double d = 1-z[i];
        if (d > 0)
            f += C[i]*d*d;
    }
    
    return(f);
}

void l2r_l2_svc_fun::grad(double *w, double *g)
{
    int i;
    double *y=prob->y;
    int l=prob->l;
    int w_size=get_nr_variable();
    
    sizeI = 0;
    for (i=0;i<l;i++)
        if (z[i] < 1)
        {
            z[sizeI] = C[i]*y[i]*(z[i]-1);
            I[sizeI] = i;
            sizeI++;
        }
    subXTv(z, g);
    
    for(i=0;i<w_size;i++)
        g[i] = w[i] + 2*g[i];
}

int l2r_l2_svc_fun::get_nr_variable(void)
{
    return prob->n;
}

void l2r_l2_svc_fun::Hv(double *s, double *Hs)
{
    int i;
    int w_size=get_nr_variable();
    double *wa = new double[sizeI];
    
    subXv(s, wa);
    for(i=0;i<sizeI;i++)
        wa[i] = C[I[i]]*wa[i];
    
    subXTv(wa, Hs);
    for(i=0;i<w_size;i++)
        Hs[i] = s[i] + 2*Hs[i];
    delete[] wa;
}

void l2r_l2_svc_fun::Xv(double *v, double *Xv)
{
    int i;
    int l=prob->l;
    feature_node **x=prob->x;
    
    for(i=0;i<l;i++)
    {
        feature_node *s=x[i];
        Xv[i]=0;
        while(s->index!=-1)
        {
            Xv[i]+=v[s->index-1]*s->value;
            s++;
        }
    }
}

void l2r_l2_svc_fun::subXv(double *v, double *Xv)
{
    int i;
    feature_node **x=prob->x;
    
    for(i=0;i<sizeI;i++)
    {
        feature_node *s=x[I[i]];
        Xv[i]=0;
        while(s->index!=-1)
        {
            Xv[i]+=v[s->index-1]*s->value;
            s++;
        }
    }
}

void l2r_l2_svc_fun::subXTv(double *v, double *XTv)
{
    int i;
    int w_size=get_nr_variable();
    feature_node **x=prob->x;
    
    for(i=0;i<w_size;i++)
        XTv[i]=0;
    for(i=0;i<sizeI;i++)
    {
        feature_node *s=x[I[i]];
        while(s->index!=-1)
        {
            XTv[s->index-1]+=v[i]*s->value;
            s++;
        }
    }
}

class l2r_l2_svr_fun: public l2r_l2_svc_fun
{
public:
    l2r_l2_svr_fun(const problem *prob, double *C, double p);
    
    double fun(double *w);
    void grad(double *w, double *g);
    
private:
    double p;
};

l2r_l2_svr_fun::l2r_l2_svr_fun(const problem *prob, double *C, double p):
l2r_l2_svc_fun(prob, C)
{
    this->p = p;
}

double l2r_l2_svr_fun::fun(double *w)
{
    int i;
    double f=0;
    double *y=prob->y;
    int l=prob->l;
    int w_size=get_nr_variable();
    double d;
    
    Xv(w, z);
    
    for(i=0;i<w_size;i++)
        f += w[i]*w[i];
    f /= 2;
    for(i=0;i<l;i++)
    {
        d = z[i] - y[i];
        if(d < -p)
            f += C[i]*(d+p)*(d+p);
        else if(d > p)
            f += C[i]*(d-p)*(d-p);
    }
    
    return(f);
}

void l2r_l2_svr_fun::grad(double *w, double *g)
{
    int i;
    double *y=prob->y;
    int l=prob->l;
    int w_size=get_nr_variable();
    double d;
    
    sizeI = 0;
    for(i=0;i<l;i++)
    {
        d = z[i] - y[i];
        
        // generate index set I
        if(d < -p)
        {
            z[sizeI] = C[i]*(d+p);
            I[sizeI] = i;
            sizeI++;
        }
        else if(d > p)
        {
            z[sizeI] = C[i]*(d-p);
            I[sizeI] = i;
            sizeI++;
        }
        
    }
    subXTv(z, g);
    
    for(i=0;i<w_size;i++)
        g[i] = w[i] + 2*g[i];
}

// A coordinate descent algorithm for
// multi-class support vector machines by Crammer and Singer
//
//  min_{\alpha}  0.5 \sum_m ||w_m(\alpha)||^2 + \sum_i \sum_m e^m_i alpha^m_i
//    s.t.     \alpha^m_i <= C^m_i \forall m,i , \sum_m \alpha^m_i=0 \forall i
//
//  where e^m_i = 0 if y_i  = m,
//        e^m_i = 1 if y_i != m,
//  C^m_i = C if m  = y_i,
//  C^m_i = 0 if m != y_i,
//  and w_m(\alpha) = \sum_i \alpha^m_i x_i
//
// Given:
// x, y, C
// eps is the stopping tolerance
//
// solution will be put in w
//
// See Appendix of LIBLINEAR paper, Fan et al. (2008)

#define GETI(i) ((int) prob->y[i])
// To support weights for instances, use GETI(i) (i)

class Solver_MCSVM_CS
{
public:
    Solver_MCSVM_CS(const problem *prob, int nr_class, double *C, double eps=0.1, int max_iter=100000);
    ~Solver_MCSVM_CS();
    void Solve(double *w);
private:
    void solve_sub_problem(double A_i, int yi, double C_yi, int active_i, double *alpha_new);
    bool be_shrunk(int i, int m, int yi, double alpha_i, double minG);
    double *B, *C, *G;
    int w_size, l;
    int nr_class;
    int max_iter;
    double eps;
    const problem *prob;
};

Solver_MCSVM_CS::Solver_MCSVM_CS(const problem *prob, int nr_class, double *weighted_C, double eps, int max_iter)
{
    this->w_size = prob->n;
    this->l = prob->l;
    this->nr_class = nr_class;
    this->eps = eps;
    this->max_iter = max_iter;
    this->prob = prob;
    this->B = new double[nr_class];
    this->G = new double[nr_class];
    this->C = weighted_C;
}

Solver_MCSVM_CS::~Solver_MCSVM_CS()
{
    delete[] B;
    delete[] G;
}

int compare_double(const void *a, const void *b)
{
    if(*(double *)a > *(double *)b)
        return -1;
    if(*(double *)a < *(double *)b)
        return 1;
    return 0;
}

void Solver_MCSVM_CS::solve_sub_problem(double A_i, int yi, double C_yi, int active_i, double *alpha_new)
{
    int r;
    double *D;
    
    clone(D, B, active_i);
    if(yi < active_i)
        D[yi] += A_i*C_yi;
    qsort(D, active_i, sizeof(double), compare_double);
    
    double beta = D[0] - A_i*C_yi;
    for(r=1;r<active_i && beta<r*D[r];r++)
        beta += D[r];
    beta /= r;
    
    for(r=0;r<active_i;r++)
    {
        if(r == yi)
            alpha_new[r] = min(C_yi, (beta-B[r])/A_i);
        else
            alpha_new[r] = min((double)0, (beta - B[r])/A_i);
    }
    delete[] D;
}

bool Solver_MCSVM_CS::be_shrunk(int i, int m, int yi, double alpha_i, double minG)
{
    double bound = 0;
    if(m == yi)
        bound = C[GETI(i)];
    if(alpha_i == bound && G[m] < minG)
        return true;
    return false;
}

void Solver_MCSVM_CS::Solve(double *w)
{
    int i, m, s;
    int iter = 0;
    double *alpha =  new double[l*nr_class];
    double *alpha_new = new double[nr_class];
    int *index = new int[l];
    double *QD = new double[l];
    int *d_ind = new int[nr_class];
    double *d_val = new double[nr_class];
    int *alpha_index = new int[nr_class*l];
    int *y_index = new int[l];
    int active_size = l;
    int *active_size_i = new int[l];
    double eps_shrink = max(10.0*eps, 1.0); // stopping tolerance for shrinking
    bool start_from_all = true;
    
    // Initial alpha can be set here. Note that
    // sum_m alpha[i*nr_class+m] = 0, for all i=1,...,l-1
    // alpha[i*nr_class+m] <= C[GETI(i)] if prob->y[i] == m
    // alpha[i*nr_class+m] <= 0 if prob->y[i] != m
    // If initial alpha isn't zero, uncomment the for loop below to initialize w
    for(i=0;i<l*nr_class;i++)
        alpha[i] = 0;
    
    for(i=0;i<w_size*nr_class;i++)
        w[i] = 0;
    for(i=0;i<l;i++)
    {
        for(m=0;m<nr_class;m++)
            alpha_index[i*nr_class+m] = m;
        feature_node *xi = prob->x[i];
        QD[i] = 0;
        while(xi->index != -1)
        {
            double val = xi->value;
            QD[i] += val*val;
            
            // Uncomment the for loop if initial alpha isn't zero
            // for(m=0; m<nr_class; m++)
            //	w[(xi->index-1)*nr_class+m] += alpha[i*nr_class+m]*val;
            xi++;
        }
        active_size_i[i] = nr_class;
        y_index[i] = (int)prob->y[i];
        index[i] = i;
    }
    
    while(iter < max_iter)
    {
        double stopping = -INF;
        for(i=0;i<active_size;i++)
        {
            int j = i+rand()%(active_size-i);
            swap(index[i], index[j]);
        }
        for(s=0;s<active_size;s++)
        {
            i = index[s];
            double Ai = QD[i];
            double *alpha_i = &alpha[i*nr_class];
            int *alpha_index_i = &alpha_index[i*nr_class];
            
            if(Ai > 0)
            {
                for(m=0;m<active_size_i[i];m++)
                    G[m] = 1;
                if(y_index[i] < active_size_i[i])
                    G[y_index[i]] = 0;
                
                feature_node *xi = prob->x[i];
                while(xi->index!= -1)
                {
                    double *w_i = &w[(xi->index-1)*nr_class];
                    for(m=0;m<active_size_i[i];m++)
                        G[m] += w_i[alpha_index_i[m]]*(xi->value);
                    xi++;
                }
                
                double minG = INF;
                double maxG = -INF;
                for(m=0;m<active_size_i[i];m++)
                {
                    if(alpha_i[alpha_index_i[m]] < 0 && G[m] < minG)
                        minG = G[m];
                    if(G[m] > maxG)
                        maxG = G[m];
                }
                if(y_index[i] < active_size_i[i])
                    if(alpha_i[(int) prob->y[i]] < C[GETI(i)] && G[y_index[i]] < minG)
                        minG = G[y_index[i]];
                
                for(m=0;m<active_size_i[i];m++)
                {
                    if(be_shrunk(i, m, y_index[i], alpha_i[alpha_index_i[m]], minG))
                    {
                        active_size_i[i]--;
                        while(active_size_i[i]>m)
                        {
                            if(!be_shrunk(i, active_size_i[i], y_index[i],
                                          alpha_i[alpha_index_i[active_size_i[i]]], minG))
                            {
                                swap(alpha_index_i[m], alpha_index_i[active_size_i[i]]);
                                swap(G[m], G[active_size_i[i]]);
                                if(y_index[i] == active_size_i[i])
                                    y_index[i] = m;
                                else if(y_index[i] == m)
                                    y_index[i] = active_size_i[i];
                                break;
                            }
                            active_size_i[i]--;
                        }
                    }
                }
                
                if(active_size_i[i] <= 1)
                {
                    active_size--;
                    swap(index[s], index[active_size]);
                    s--;
                    continue;
                }
                
                if(maxG-minG <= 1e-12)
                    continue;
                else
                    stopping = max(maxG - minG, stopping);
                
                for(m=0;m<active_size_i[i];m++)
                    B[m] = G[m] - Ai*alpha_i[alpha_index_i[m]] ;
                
                solve_sub_problem(Ai, y_index[i], C[GETI(i)], active_size_i[i], alpha_new);
                int nz_d = 0;
                for(m=0;m<active_size_i[i];m++)
                {
                    double d = alpha_new[m] - alpha_i[alpha_index_i[m]];
                    alpha_i[alpha_index_i[m]] = alpha_new[m];
                    if(fabs(d) >= 1e-12)
                    {
                        d_ind[nz_d] = alpha_index_i[m];
                        d_val[nz_d] = d;
                        nz_d++;
                    }
                }
                
                xi = prob->x[i];
                while(xi->index != -1)
                {
                    double *w_i = &w[(xi->index-1)*nr_class];
                    for(m=0;m<nz_d;m++)
                        w_i[d_ind[m]] += d_val[m]*xi->value;
                    xi++;
                }
            }
        }
        
        iter++;
        if(iter % 10 == 0)
        {
            info(".");
        }
        
        if(stopping < eps_shrink)
        {
            if(stopping < eps && start_from_all == true)
                break;
            else
            {
                active_size = l;
                for(i=0;i<l;i++)
                    active_size_i[i] = nr_class;
                info("*");
                eps_shrink = max(eps_shrink/2, eps);
                start_from_all = true;
            }
        }
        else
            start_from_all = false;
    }
    
    info("\noptimization finished, #iter = %d\n",iter);
    if (iter >= max_iter)
        info("\nWARNING: reaching max number of iterations\n");
    
    // calculate objective value
    double v = 0;
    int nSV = 0;
    for(i=0;i<w_size*nr_class;i++)
        v += w[i]*w[i];
    v = 0.5*v;
    for(i=0;i<l*nr_class;i++)
    {
        v += alpha[i];
        if(fabs(alpha[i]) > 0)
            nSV++;
    }
    for(i=0;i<l;i++)
        v -= alpha[i*nr_class+(int)prob->y[i]];
    info("Objective value = %lf\n",v);
    info("nSV = %d\n",nSV);
    
    delete [] alpha;
    delete [] alpha_new;
    delete [] index;
    delete [] QD;
    delete [] d_ind;
    delete [] d_val;
    delete [] alpha_index;
    delete [] y_index;
    delete [] active_size_i;
}

// A coordinate descent algorithm for
// L1-loss and L2-loss SVM dual problems
//
//  min_\alpha  0.5(\alpha^T (Q + D)\alpha) - e^T \alpha,
//    s.t.      0 <= \alpha_i <= upper_bound_i,
//
//  where Qij = yi yj xi^T xj and
//  D is a diagonal matrix
//
// In L1-SVM case:
// 		upper_bound_i = Cp if y_i = 1
// 		upper_bound_i = Cn if y_i = -1
// 		D_ii = 0
// In L2-SVM case:
// 		upper_bound_i = INF
// 		D_ii = 1/(2*Cp)	if y_i = 1
// 		D_ii = 1/(2*Cn)	if y_i = -1
//
// Given:
// x, y, Cp, Cn
// eps is the stopping tolerance
//
// solution will be put in w
//
// See Algorithm 3 of Hsieh et al., ICML 2008

#undef GETI
#define GETI(i) (y[i]+1)
// To support weights for instances, use GETI(i) (i)

static void solve_l2r_l1l2_svc(
                               const problem *prob, double *w, double eps,
                               double Cp, double Cn, int solver_type)
{
    int l = prob->l;
    int w_size = prob->n;
    int i, s, iter = 0;
    double C, d, G;
    double *QD = new double[l];
    int max_iter = 1000;
    int *index = new int[l];
    double *alpha = new double[l];
    schar *y = new schar[l];
    int active_size = l;
    
    // PG: projected gradient, for shrinking and stopping
    double PG;
    double PGmax_old = INF;
    double PGmin_old = -INF;
    double PGmax_new, PGmin_new;
    
    // default solver_type: L2R_L2LOSS_SVC_DUAL
    double diag[3] = {0.5/Cn, 0, 0.5/Cp};
    double upper_bound[3] = {INF, 0, INF};
    if(solver_type == L2R_L1LOSS_SVC_DUAL)
    {
        diag[0] = 0;
        diag[2] = 0;
        upper_bound[0] = Cn;
        upper_bound[2] = Cp;
    }
    
    for(i=0; i<l; i++)
    {
        if(prob->y[i] > 0)
        {
            y[i] = +1;
        }
        else
        {
            y[i] = -1;
        }
    }
    
    // Initial alpha can be set here. Note that
    // 0 <= alpha[i] <= upper_bound[GETI(i)]
    for(i=0; i<l; i++)
        alpha[i] = 0;
    
    for(i=0; i<w_size; i++)
        w[i] = 0;
    for(i=0; i<l; i++)
    {
        QD[i] = diag[GETI(i)];
        
        feature_node *xi = prob->x[i];
        while (xi->index != -1)
        {
            double val = xi->value;
            QD[i] += val*val;
            w[xi->index-1] += y[i]*alpha[i]*val;
            xi++;
        }
        index[i] = i;
    }
    
    while (iter < max_iter)
    {
        PGmax_new = -INF;
        PGmin_new = INF;
        
        for (i=0; i<active_size; i++)
        {
            int j = i+rand()%(active_size-i);
            swap(index[i], index[j]);
        }
        
        for (s=0; s<active_size; s++)
        {
            i = index[s];
            G = 0;
            schar yi = y[i];
            
            feature_node *xi = prob->x[i];
            while(xi->index!= -1)
            {
                G += w[xi->index-1]*(xi->value);
                xi++;
            }
            G = G*yi-1;
            
            C = upper_bound[GETI(i)];
            G += alpha[i]*diag[GETI(i)];
            
            PG = 0;
            if (alpha[i] == 0)
            {
                if (G > PGmax_old)
                {
                    active_size--;
                    swap(index[s], index[active_size]);
                    s--;
                    continue;
                }
                else if (G < 0)
                    PG = G;
            }
            else if (alpha[i] == C)
            {
                if (G < PGmin_old)
                {
                    active_size--;
                    swap(index[s], index[active_size]);
                    s--;
                    continue;
                }
                else if (G > 0)
                    PG = G;
            }
            else
                PG = G;
            
            PGmax_new = max(PGmax_new, PG);
            PGmin_new = min(PGmin_new, PG);
            
            if(fabs(PG) > 1.0e-12)
            {
                double alpha_old = alpha[i];
                alpha[i] = min(max(alpha[i] - G/QD[i], 0.0), C);
                d = (alpha[i] - alpha_old)*yi;
                xi = prob->x[i];
                while (xi->index != -1)
                {
                    w[xi->index-1] += d*xi->value;
                    xi++;
                }
            }
        }
        
        iter++;
        if(iter % 10 == 0)
            info(".");
        
        if(PGmax_new - PGmin_new <= eps)
        {
            if(active_size == l)
                break;
            else
            {
                active_size = l;
                info("*");
                PGmax_old = INF;
                PGmin_old = -INF;
                continue;
            }
        }
        PGmax_old = PGmax_new;
        PGmin_old = PGmin_new;
        if (PGmax_old <= 0)
            PGmax_old = INF;
        if (PGmin_old >= 0)
            PGmin_old = -INF;
    }
    
    info("\noptimization finished, #iter = %d\n",iter);
    if (iter >= max_iter)
        info("\nWARNING: reaching max number of iterations\nUsing -s 2 may be faster (also see FAQ)\n\n");
    
    // calculate objective value
    
    double v = 0;
    int nSV = 0;
    for(i=0; i<w_size; i++)
        v += w[i]*w[i];
    for(i=0; i<l; i++)
    {
        v += alpha[i]*(alpha[i]*diag[GETI(i)] - 2);
        if(alpha[i] > 0)
            ++nSV;
    }
    info("Objective value = %lf\n",v/2);
    info("nSV = %d\n",nSV);
    
    delete [] QD;
    delete [] alpha;
    delete [] y;
    delete [] index;
}


// A coordinate descent algorithm for
// L1-loss and L2-loss epsilon-SVR dual problem
//
//  min_\beta  0.5\beta^T (Q + diag(lambda)) \beta - p \sum_{i=1}^l|\beta_i| + \sum_{i=1}^l yi\beta_i,
//    s.t.      -upper_bound_i <= \beta_i <= upper_bound_i,
//
//  where Qij = xi^T xj and
//  D is a diagonal matrix
//
// In L1-SVM case:
// 		upper_bound_i = C
// 		lambda_i = 0
// In L2-SVM case:
// 		upper_bound_i = INF
// 		lambda_i = 1/(2*C)
//
// Given:
// x, y, p, C
// eps is the stopping tolerance
//
// solution will be put in w
//
// See Algorithm 4 of Ho and Lin, 2012

#undef GETI
#define GETI(i) (0)
// To support weights for instances, use GETI(i) (i)

static void solve_l2r_l1l2_svr(
                               const problem *prob, double *w, const parameter *param,
                               int solver_type)
{
    int l = prob->l;
    double C = param->C;
    double p = param->p;
    int w_size = prob->n;
    double eps = param->eps;
    int i, s, iter = 0;
    int max_iter = 1000;
    int active_size = l;
    int *index = new int[l];
    
    double d, G, H;
    double Gmax_old = INF;
    double Gmax_new, Gnorm1_new;
    double Gnorm1_init = -1.0; // Gnorm1_init is initialized at the first iteration
    double *beta = new double[l];
    double *QD = new double[l];
    double *y = prob->y;
    
    // L2R_L2LOSS_SVR_DUAL
    double lambda[1], upper_bound[1];
    lambda[0] = 0.5/C;
    upper_bound[0] = INF;
    
    if(solver_type == L2R_L1LOSS_SVR_DUAL)
    {
        lambda[0] = 0;
        upper_bound[0] = C;
    }
    
    // Initial beta can be set here. Note that
    // -upper_bound <= beta[i] <= upper_bound
    for(i=0; i<l; i++)
        beta[i] = 0;
    
    for(i=0; i<w_size; i++)
        w[i] = 0;
    for(i=0; i<l; i++)
    {
        QD[i] = 0;
        feature_node *xi = prob->x[i];
        while(xi->index != -1)
        {
            double val = xi->value;
            QD[i] += val*val;
            w[xi->index-1] += beta[i]*val;
            xi++;
        }
        
        index[i] = i;
    }
    
    
    while(iter < max_iter)
    {
        Gmax_new = 0;
        Gnorm1_new = 0;
        
        for(i=0; i<active_size; i++)
        {
            int j = i+rand()%(active_size-i);
            swap(index[i], index[j]);
        }
        
        for(s=0; s<active_size; s++)
        {
            i = index[s];
            G = -y[i] + lambda[GETI(i)]*beta[i];
            H = QD[i] + lambda[GETI(i)];
            
            feature_node *xi = prob->x[i];
            while(xi->index != -1)
            {
                int ind = xi->index-1;
                double val = xi->value;
                G += val*w[ind];
                xi++;
            }
            
            double Gp = G+p;
            double Gn = G-p;
            double violation = 0;
            if(beta[i] == 0)
            {
                if(Gp < 0)
                    violation = -Gp;
                else if(Gn > 0)
                    violation = Gn;
                else if(Gp>Gmax_old && Gn<-Gmax_old)
                {
                    active_size--;
                    swap(index[s], index[active_size]);
                    s--;
                    continue;
                }
            }
            else if(beta[i] >= upper_bound[GETI(i)])
            {
                if(Gp > 0)
                    violation = Gp;
                else if(Gp < -Gmax_old)
                {
                    active_size--;
                    swap(index[s], index[active_size]);
                    s--;
                    continue;
                }
            }
            else if(beta[i] <= -upper_bound[GETI(i)])
            {
                if(Gn < 0)
                    violation = -Gn;
                else if(Gn > Gmax_old)
                {
                    active_size--;
                    swap(index[s], index[active_size]);
                    s--;
                    continue;
                }
            }
            else if(beta[i] > 0)
                violation = fabs(Gp);
            else
                violation = fabs(Gn);
            
            Gmax_new = max(Gmax_new, violation);
            Gnorm1_new += violation;
            
            // obtain Newton direction d
            if(Gp < H*beta[i])
                d = -Gp/H;
            else if(Gn > H*beta[i])
                d = -Gn/H;
            else
                d = -beta[i];
            
            if(fabs(d) < 1.0e-12)
                continue;
            
            double beta_old = beta[i];
            beta[i] = min(max(beta[i]+d, -upper_bound[GETI(i)]), upper_bound[GETI(i)]);
            d = beta[i]-beta_old;
            
            if(d != 0)
            {
                xi = prob->x[i];
                while(xi->index != -1)
                {
                    w[xi->index-1] += d*xi->value;
                    xi++;
                }
            }
        }
        
        if(iter == 0)
            Gnorm1_init = Gnorm1_new;
        iter++;
        if(iter % 10 == 0)
            info(".");
        
        if(Gnorm1_new <= eps*Gnorm1_init)
        {
            if(active_size == l)
                break;
            else
            {
                active_size = l;
                info("*");
                Gmax_old = INF;
                continue;
            }
        }
        
        Gmax_old = Gmax_new;
    }
    
    info("\noptimization finished, #iter = %d\n", iter);
    if(iter >= max_iter)
        info("\nWARNING: reaching max number of iterations\nUsing -s 11 may be faster\n\n");
    
    // calculate objective value
    double v = 0;
    int nSV = 0;
    for(i=0; i<w_size; i++)
        v += w[i]*w[i];
    v = 0.5*v;
    for(i=0; i<l; i++)
    {
        v += p*fabs(beta[i]) - y[i]*beta[i] + 0.5*lambda[GETI(i)]*beta[i]*beta[i];
        if(beta[i] != 0)
            nSV++;
    }
    
    info("Objective value = %lf\n", v);
    info("nSV = %d\n",nSV);
    
    delete [] beta;
    delete [] QD;
    delete [] index;
}


// A coordinate descent algorithm for
// the dual of L2-regularized logistic regression problems
//
//  min_\alpha  0.5(\alpha^T Q \alpha) + \sum \alpha_i log (\alpha_i) + (upper_bound_i - \alpha_i) log (upper_bound_i - \alpha_i),
//    s.t.      0 <= \alpha_i <= upper_bound_i,
//
//  where Qij = yi yj xi^T xj and
//  upper_bound_i = Cp if y_i = 1
//  upper_bound_i = Cn if y_i = -1
//
// Given:
// x, y, Cp, Cn
// eps is the stopping tolerance
//
// solution will be put in w
//
// See Algorithm 5 of Yu et al., MLJ 2010

#undef GETI
#define GETI(i) (y[i]+1)
// To support weights for instances, use GETI(i) (i)

void solve_l2r_lr_dual(const problem *prob, double *w, double eps, double Cp, double Cn)
{
    int l = prob->l;
    int w_size = prob->n;
    int i, s, iter = 0;
    double *xTx = new double[l];
    int max_iter = 1000;
    int *index = new int[l];
    double *alpha = new double[2*l]; // store alpha and C - alpha
    schar *y = new schar[l];
    int max_inner_iter = 100; // for inner Newton
    double innereps = 1e-2;
    double innereps_min = min(1e-8, eps);
    double upper_bound[3] = {Cn, 0, Cp};
    
    for(i=0; i<l; i++)
    {
        if(prob->y[i] > 0)
        {
            y[i] = +1;
        }
        else
        {
            y[i] = -1;
        }
    }
    
    // Initial alpha can be set here. Note that
    // 0 < alpha[i] < upper_bound[GETI(i)]
    // alpha[2*i] + alpha[2*i+1] = upper_bound[GETI(i)]
    for(i=0; i<l; i++)
    {
        alpha[2*i] = min(0.001*upper_bound[GETI(i)], 1e-8);
        alpha[2*i+1] = upper_bound[GETI(i)] - alpha[2*i];
    }
    
    for(i=0; i<w_size; i++)
        w[i] = 0;
    for(i=0; i<l; i++)
    {
        xTx[i] = 0;
        feature_node *xi = prob->x[i];
        while (xi->index != -1)
        {
            double val = xi->value;
            xTx[i] += val*val;
            w[xi->index-1] += y[i]*alpha[2*i]*val;
            xi++;
        }
        index[i] = i;
    }
    
    while (iter < max_iter)
    {
        for (i=0; i<l; i++)
        {
            int j = i+rand()%(l-i);
            swap(index[i], index[j]);
        }
        int newton_iter = 0;
        double Gmax = 0;
        for (s=0; s<l; s++)
        {
            i = index[s];
            schar yi = y[i];
            double C = upper_bound[GETI(i)];
            double ywTx = 0, xisq = xTx[i];
            feature_node *xi = prob->x[i];
            while (xi->index != -1)
            {
                ywTx += w[xi->index-1]*xi->value;
                xi++;
            }
            ywTx *= y[i];
            double a = xisq, b = ywTx;
            
            // Decide to minimize g_1(z) or g_2(z)
            int ind1 = 2*i, ind2 = 2*i+1, sign = 1;
            if(0.5*a*(alpha[ind2]-alpha[ind1])+b < 0)
            {
                ind1 = 2*i+1;
                ind2 = 2*i;
                sign = -1;
            }
            
            //  g_t(z) = z*log(z) + (C-z)*log(C-z) + 0.5a(z-alpha_old)^2 + sign*b(z-alpha_old)
            double alpha_old = alpha[ind1];
            double z = alpha_old;
            if(C - z < 0.5 * C)
                z = 0.1*z;
            double gp = a*(z-alpha_old)+sign*b+log(z/(C-z));
            Gmax = max(Gmax, fabs(gp));
            
            // Newton method on the sub-problem
            const double eta = 0.1; // xi in the paper
            int inner_iter = 0;
            while (inner_iter <= max_inner_iter)
            {
                if(fabs(gp) < innereps)
                    break;
                double gpp = a + C/(C-z)/z;
                double tmpz = z - gp/gpp;
                if(tmpz <= 0)
                    z *= eta;
                else // tmpz in (0, C)
                    z = tmpz;
                gp = a*(z-alpha_old)+sign*b+log(z/(C-z));
                newton_iter++;
                inner_iter++;
            }
            
            if(inner_iter > 0) // update w
            {
                alpha[ind1] = z;
                alpha[ind2] = C-z;
                xi = prob->x[i];
                while (xi->index != -1)
                {
                    w[xi->index-1] += sign*(z-alpha_old)*yi*xi->value;
                    xi++;
                }
            }
        }
        
        iter++;
        if(iter % 10 == 0)
            info(".");
        
        if(Gmax < eps)
            break;
        
        if(newton_iter <= l/10)
            innereps = max(innereps_min, 0.1*innereps);
        
    }
    
    info("\noptimization finished, #iter = %d\n",iter);
    if (iter >= max_iter)
        info("\nWARNING: reaching max number of iterations\nUsing -s 0 may be faster (also see FAQ)\n\n");
    
    // calculate objective value
    
    double v = 0;
    for(i=0; i<w_size; i++)
        v += w[i] * w[i];
    v *= 0.5;
    for(i=0; i<l; i++)
        v += alpha[2*i] * log(alpha[2*i]) + alpha[2*i+1] * log(alpha[2*i+1])
        - upper_bound[GETI(i)] * log(upper_bound[GETI(i)]);
    info("Objective value = %lf\n", v);
    
    delete [] xTx;
    delete [] alpha;
    delete [] y;
    delete [] index;
}

// A coordinate descent algorithm for
// L1-regularized L2-loss support vector classification
//
//  min_w \sum |wj| + C \sum max(0, 1-yi w^T xi)^2,
//
// Given:
// x, y, Cp, Cn
// eps is the stopping tolerance
//
// solution will be put in w
//
// See Yuan et al. (2010) and appendix of LIBLINEAR paper, Fan et al. (2008)

#undef GETI
#define GETI(i) (y[i]+1)
// To support weights for instances, use GETI(i) (i)

static void solve_l1r_l2_svc(
                             problem *prob_col, double *w, double eps,
                             double Cp, double Cn)
{
    int l = prob_col->l;
    int w_size = prob_col->n;
    int j, s, iter = 0;
    int max_iter = 1000;
    int active_size = w_size;
    int max_num_linesearch = 20;
    
    double sigma = 0.01;
    double d, G_loss, G, H;
    double Gmax_old = INF;
    double Gmax_new, Gnorm1_new;
    double Gnorm1_init = -1.0; // Gnorm1_init is initialized at the first iteration
    double d_old, d_diff;
    double loss_old, loss_new;
    double appxcond, cond;
    
    int *index = new int[w_size];
    schar *y = new schar[l];
    double *b = new double[l]; // b = 1-ywTx
    double *xj_sq = new double[w_size];
    feature_node *x;
    
    double C[3] = {Cn,0,Cp};
    
    // Initial w can be set here.
    for(j=0; j<w_size; j++)
        w[j] = 0;
    
    for(j=0; j<l; j++)
    {
        b[j] = 1;
        if(prob_col->y[j] > 0)
            y[j] = 1;
        else
            y[j] = -1;
    }
    for(j=0; j<w_size; j++)
    {
        index[j] = j;
        xj_sq[j] = 0;
        x = prob_col->x[j];
        while(x->index != -1)
        {
            int ind = x->index-1;
            x->value *= y[ind]; // x->value stores yi*xij
            double val = x->value;
            b[ind] -= w[j]*val;
            xj_sq[j] += C[GETI(ind)]*val*val;
            x++;
        }
    }
    
    while(iter < max_iter)
    {
        Gmax_new = 0;
        Gnorm1_new = 0;
        
        for(j=0; j<active_size; j++)
        {
            int i = j+rand()%(active_size-j);
            swap(index[i], index[j]);
        }
        
        for(s=0; s<active_size; s++)
        {
            j = index[s];
            G_loss = 0;
            H = 0;
            
            x = prob_col->x[j];
            while(x->index != -1)
            {
                int ind = x->index-1;
                if(b[ind] > 0)
                {
                    double val = x->value;
                    double tmp = C[GETI(ind)]*val;
                    G_loss -= tmp*b[ind];
                    H += tmp*val;
                }
                x++;
            }
            G_loss *= 2;
            
            G = G_loss;
            H *= 2;
            H = max(H, 1e-12);
            
            double Gp = G+1;
            double Gn = G-1;
            double violation = 0;
            if(w[j] == 0)
            {
                if(Gp < 0)
                    violation = -Gp;
                else if(Gn > 0)
                    violation = Gn;
                else if(Gp>Gmax_old/l && Gn<-Gmax_old/l)
                {
                    active_size--;
                    swap(index[s], index[active_size]);
                    s--;
                    continue;
                }
            }
            else if(w[j] > 0)
                violation = fabs(Gp);
            else
                violation = fabs(Gn);
            
            Gmax_new = max(Gmax_new, violation);
            Gnorm1_new += violation;
            
            // obtain Newton direction d
            if(Gp < H*w[j])
                d = -Gp/H;
            else if(Gn > H*w[j])
                d = -Gn/H;
            else
                d = -w[j];
            
            if(fabs(d) < 1.0e-12)
                continue;
            
            double delta = fabs(w[j]+d)-fabs(w[j]) + G*d;
            d_old = 0;
            int num_linesearch;
            for(num_linesearch=0; num_linesearch < max_num_linesearch; num_linesearch++)
            {
                d_diff = d_old - d;
                cond = fabs(w[j]+d)-fabs(w[j]) - sigma*delta;
                
                appxcond = xj_sq[j]*d*d + G_loss*d + cond;
                if(appxcond <= 0)
                {
                    x = prob_col->x[j];
                    while(x->index != -1)
                    {
                        b[x->index-1] += d_diff*x->value;
                        x++;
                    }
                    break;
                }
                
                if(num_linesearch == 0)
                {
                    loss_old = 0;
                    loss_new = 0;
                    x = prob_col->x[j];
                    while(x->index != -1)
                    {
                        int ind = x->index-1;
                        if(b[ind] > 0)
                            loss_old += C[GETI(ind)]*b[ind]*b[ind];
                        double b_new = b[ind] + d_diff*x->value;
                        b[ind] = b_new;
                        if(b_new > 0)
                            loss_new += C[GETI(ind)]*b_new*b_new;
                        x++;
                    }
                }
                else
                {
                    loss_new = 0;
                    x = prob_col->x[j];
                    while(x->index != -1)
                    {
                        int ind = x->index-1;
                        double b_new = b[ind] + d_diff*x->value;
                        b[ind] = b_new;
                        if(b_new > 0)
                            loss_new += C[GETI(ind)]*b_new*b_new;
                        x++;
                    }
                }
                
                cond = cond + loss_new - loss_old;
                if(cond <= 0)
                    break;
                else
                {
                    d_old = d;
                    d *= 0.5;
                    delta *= 0.5;
                }
            }
            
            w[j] += d;
            
            // recompute b[] if line search takes too many steps
            if(num_linesearch >= max_num_linesearch)
            {
                info("#");
                for(int i=0; i<l; i++)
                    b[i] = 1;
                
                for(int i=0; i<w_size; i++)
                {
                    if(w[i]==0) continue;
                    x = prob_col->x[i];
                    while(x->index != -1)
                    {
                        b[x->index-1] -= w[i]*x->value;
                        x++;
                    }
                }
            }
        }
        
        if(iter == 0)
            Gnorm1_init = Gnorm1_new;
        iter++;
        if(iter % 10 == 0)
            info(".");
        
        if(Gnorm1_new <= eps*Gnorm1_init)
        {
            if(active_size == w_size)
                break;
            else
            {
                active_size = w_size;
                info("*");
                Gmax_old = INF;
                continue;
            }
        }
        
        Gmax_old = Gmax_new;
    }
    
    info("\noptimization finished, #iter = %d\n", iter);
    if(iter >= max_iter)
        info("\nWARNING: reaching max number of iterations\n");
    
    // calculate objective value
    
    double v = 0;
    int nnz = 0;
    for(j=0; j<w_size; j++)
    {
        x = prob_col->x[j];
        while(x->index != -1)
        {
            x->value *= prob_col->y[x->index-1]; // restore x->value
            x++;
        }
        if(w[j] != 0)
        {
            v += fabs(w[j]);
            nnz++;
        }
    }
    for(j=0; j<l; j++)
        if(b[j] > 0)
            v += C[GETI(j)]*b[j]*b[j];
    
    info("Objective value = %lf\n", v);
    info("#nonzeros/#features = %d/%d\n", nnz, w_size);
    
    delete [] index;
    delete [] y;
    delete [] b;
    delete [] xj_sq;
}

// A coordinate descent algorithm for
// L1-regularized logistic regression problems
//
//  min_w \sum |wj| + C \sum log(1+exp(-yi w^T xi)),
//
// Given:
// x, y, Cp, Cn
// eps is the stopping tolerance
//
// solution will be put in w
//
// See Yuan et al. (2011) and appendix of LIBLINEAR paper, Fan et al. (2008)

#undef GETI
#define GETI(i) (y[i]+1)
// To support weights for instances, use GETI(i) (i)

static void solve_l1r_lr(
                         const problem *prob_col, double *w, double eps,
                         double Cp, double Cn)
{
    int l = prob_col->l;
    int w_size = prob_col->n;
    int j, s, newton_iter=0, iter=0;
    int max_newton_iter = 100;
    int max_iter = 1000;
    int max_num_linesearch = 20;
    int active_size;
    int QP_active_size;
    
    double nu = 1e-12;
    double inner_eps = 1;
    double sigma = 0.01;
    double w_norm, w_norm_new;
    double z, G, H;
    double Gnorm1_init = -1.0; // Gnorm1_init is initialized at the first iteration
    double Gmax_old = INF;
    double Gmax_new, Gnorm1_new;
    double QP_Gmax_old = INF;
    double QP_Gmax_new, QP_Gnorm1_new;
    double delta, negsum_xTd, cond;
    
    int *index = new int[w_size];
    schar *y = new schar[l];
    double *Hdiag = new double[w_size];
    double *Grad = new double[w_size];
    double *wpd = new double[w_size];
    double *xjneg_sum = new double[w_size];
    double *xTd = new double[l];
    double *exp_wTx = new double[l];
    double *exp_wTx_new = new double[l];
    double *tau = new double[l];
    double *D = new double[l];
    feature_node *x;
    
    double C[3] = {Cn,0,Cp};
    
    // Initial w can be set here.
    for(j=0; j<w_size; j++)
        w[j] = 0;
    
    for(j=0; j<l; j++)
    {
        if(prob_col->y[j] > 0)
            y[j] = 1;
        else
            y[j] = -1;
        
        exp_wTx[j] = 0;
    }
    
    w_norm = 0;
    for(j=0; j<w_size; j++)
    {
        w_norm += fabs(w[j]);
        wpd[j] = w[j];
        index[j] = j;
        xjneg_sum[j] = 0;
        x = prob_col->x[j];
        while(x->index != -1)
        {
            int ind = x->index-1;
            double val = x->value;
            exp_wTx[ind] += w[j]*val;
            if(y[ind] == -1)
                xjneg_sum[j] += C[GETI(ind)]*val;
            x++;
        }
    }
    for(j=0; j<l; j++)
    {
        exp_wTx[j] = exp(exp_wTx[j]);
        double tau_tmp = 1/(1+exp_wTx[j]);
        tau[j] = C[GETI(j)]*tau_tmp;
        D[j] = C[GETI(j)]*exp_wTx[j]*tau_tmp*tau_tmp;
    }
    
    while(newton_iter < max_newton_iter)
    {
        Gmax_new = 0;
        Gnorm1_new = 0;
        active_size = w_size;
        
        for(s=0; s<active_size; s++)
        {
            j = index[s];
            Hdiag[j] = nu;
            Grad[j] = 0;
            
            double tmp = 0;
            x = prob_col->x[j];
            while(x->index != -1)
            {
                int ind = x->index-1;
                Hdiag[j] += x->value*x->value*D[ind];
                tmp += x->value*tau[ind];
                x++;
            }
            Grad[j] = -tmp + xjneg_sum[j];
            
            double Gp = Grad[j]+1;
            double Gn = Grad[j]-1;
            double violation = 0;
            if(w[j] == 0)
            {
                if(Gp < 0)
                    violation = -Gp;
                else if(Gn > 0)
                    violation = Gn;
                //outer-level shrinking
                else if(Gp>Gmax_old/l && Gn<-Gmax_old/l)
                {
                    active_size--;
                    swap(index[s], index[active_size]);
                    s--;
                    continue;
                }
            }
            else if(w[j] > 0)
                violation = fabs(Gp);
            else
                violation = fabs(Gn);
            
            Gmax_new = max(Gmax_new, violation);
            Gnorm1_new += violation;
        }
        
        if(newton_iter == 0)
            Gnorm1_init = Gnorm1_new;
        
        if(Gnorm1_new <= eps*Gnorm1_init)
            break;
        
        iter = 0;
        QP_Gmax_old = INF;
        QP_active_size = active_size;
        
        for(int i=0; i<l; i++)
            xTd[i] = 0;
        
        // optimize QP over wpd
        while(iter < max_iter)
        {
            QP_Gmax_new = 0;
            QP_Gnorm1_new = 0;
            
            for(j=0; j<QP_active_size; j++)
            {
                int i = j+rand()%(QP_active_size-j);
                swap(index[i], index[j]);
            }
            
            for(s=0; s<QP_active_size; s++)
            {
                j = index[s];
                H = Hdiag[j];
                
                x = prob_col->x[j];
                G = Grad[j] + (wpd[j]-w[j])*nu;
                while(x->index != -1)
                {
                    int ind = x->index-1;
                    G += x->value*D[ind]*xTd[ind];
                    x++;
                }
                
                double Gp = G+1;
                double Gn = G-1;
                double violation = 0;
                if(wpd[j] == 0)
                {
                    if(Gp < 0)
                        violation = -Gp;
                    else if(Gn > 0)
                        violation = Gn;
                    //inner-level shrinking
                    else if(Gp>QP_Gmax_old/l && Gn<-QP_Gmax_old/l)
                    {
                        QP_active_size--;
                        swap(index[s], index[QP_active_size]);
                        s--;
                        continue;
                    }
                }
                else if(wpd[j] > 0)
                    violation = fabs(Gp);
                else
                    violation = fabs(Gn);
                
                QP_Gmax_new = max(QP_Gmax_new, violation);
                QP_Gnorm1_new += violation;
                
                // obtain solution of one-variable problem
                if(Gp < H*wpd[j])
                    z = -Gp/H;
                else if(Gn > H*wpd[j])
                    z = -Gn/H;
                else
                    z = -wpd[j];
                
                if(fabs(z) < 1.0e-12)
                    continue;
                z = min(max(z,-10.0),10.0);
                
                wpd[j] += z;
                
                x = prob_col->x[j];
                while(x->index != -1)
                {
                    int ind = x->index-1;
                    xTd[ind] += x->value*z;
                    x++;
                }
            }
            
            iter++;
            
            if(QP_Gnorm1_new <= inner_eps*Gnorm1_init)
            {
                //inner stopping
                if(QP_active_size == active_size)
                    break;
                //active set reactivation
                else
                {
                    QP_active_size = active_size;
                    QP_Gmax_old = INF;
                    continue;
                }
            }
            
            QP_Gmax_old = QP_Gmax_new;
        }
        
        if(iter >= max_iter)
            info("WARNING: reaching max number of inner iterations\n");
        
        delta = 0;
        w_norm_new = 0;
        for(j=0; j<w_size; j++)
        {
            delta += Grad[j]*(wpd[j]-w[j]);
            if(wpd[j] != 0)
                w_norm_new += fabs(wpd[j]);
        }
        delta += (w_norm_new-w_norm);
        
        negsum_xTd = 0;
        for(int i=0; i<l; i++)
            if(y[i] == -1)
                negsum_xTd += C[GETI(i)]*xTd[i];
        
        int num_linesearch;
        for(num_linesearch=0; num_linesearch < max_num_linesearch; num_linesearch++)
        {
            cond = w_norm_new - w_norm + negsum_xTd - sigma*delta;
            
            for(int i=0; i<l; i++)
            {
                double exp_xTd = exp(xTd[i]);
                exp_wTx_new[i] = exp_wTx[i]*exp_xTd;
                cond += C[GETI(i)]*log((1+exp_wTx_new[i])/(exp_xTd+exp_wTx_new[i]));
            }
            
            if(cond <= 0)
            {
                w_norm = w_norm_new;
                for(j=0; j<w_size; j++)
                    w[j] = wpd[j];
                for(int i=0; i<l; i++)
                {
                    exp_wTx[i] = exp_wTx_new[i];
                    double tau_tmp = 1/(1+exp_wTx[i]);
                    tau[i] = C[GETI(i)]*tau_tmp;
                    D[i] = C[GETI(i)]*exp_wTx[i]*tau_tmp*tau_tmp;
                }
                break;
            }
            else
            {
                w_norm_new = 0;
                for(j=0; j<w_size; j++)
                {
                    wpd[j] = (w[j]+wpd[j])*0.5;
                    if(wpd[j] != 0)
                        w_norm_new += fabs(wpd[j]);
                }
                delta *= 0.5;
                negsum_xTd *= 0.5;
                for(int i=0; i<l; i++)
                    xTd[i] *= 0.5;
            }
        }
        
        // Recompute some info due to too many line search steps
        if(num_linesearch >= max_num_linesearch)
        {
            for(int i=0; i<l; i++)
                exp_wTx[i] = 0;
            
            for(int i=0; i<w_size; i++)
            {
                if(w[i]==0) continue;
                x = prob_col->x[i];
                while(x->index != -1)
                {
                    exp_wTx[x->index-1] += w[i]*x->value;
                    x++;
                }
            }
            
            for(int i=0; i<l; i++)
                exp_wTx[i] = exp(exp_wTx[i]);
        }
        
        if(iter == 1)
            inner_eps *= 0.25;
        
        newton_iter++;
        Gmax_old = Gmax_new;
        
        info("iter %3d  #CD cycles %d\n", newton_iter, iter);
    }
    
    info("=========================\n");
    info("optimization finished, #iter = %d\n", newton_iter);
    if(newton_iter >= max_newton_iter)
        info("WARNING: reaching max number of iterations\n");
    
    // calculate objective value
    
    double v = 0;
    int nnz = 0;
    for(j=0; j<w_size; j++)
        if(w[j] != 0)
        {
            v += fabs(w[j]);
            nnz++;
        }
    for(j=0; j<l; j++)
        if(y[j] == 1)
            v += C[GETI(j)]*log(1+1/exp_wTx[j]);
        else
            v += C[GETI(j)]*log(1+exp_wTx[j]);
    
    info("Objective value = %lf\n", v);
    info("#nonzeros/#features = %d/%d\n", nnz, w_size);
    
    delete [] index;
    delete [] y;
    delete [] Hdiag;
    delete [] Grad;
    delete [] wpd;
    delete [] xjneg_sum;
    delete [] xTd;
    delete [] exp_wTx;
    delete [] exp_wTx_new;
    delete [] tau;
    delete [] D;
}

// transpose matrix X from row format to column format
static void transpose(const problem *prob, feature_node **x_space_ret, problem *prob_col)
{
    int i;
    int l = prob->l;
    int n = prob->n;
    size_t nnz = 0;
    size_t *col_ptr = new size_t [n+1];
    feature_node *x_space;
    prob_col->l = l;
    prob_col->n = n;
    prob_col->y = new double[l];
    prob_col->x = new feature_node*[n];
    
    for(i=0; i<l; i++)
        prob_col->y[i] = prob->y[i];
    
    for(i=0; i<n+1; i++)
        col_ptr[i] = 0;
    for(i=0; i<l; i++)
    {
        feature_node *x = prob->x[i];
        while(x->index != -1)
        {
            nnz++;
            col_ptr[x->index]++;
            x++;
        }
    }
    for(i=1; i<n+1; i++)
        col_ptr[i] += col_ptr[i-1] + 1;
    
    x_space = new feature_node[nnz+n];
    for(i=0; i<n; i++)
        prob_col->x[i] = &x_space[col_ptr[i]];
    
    for(i=0; i<l; i++)
    {
        feature_node *x = prob->x[i];
        while(x->index != -1)
        {
            int ind = x->index-1;
            x_space[col_ptr[ind]].index = i+1; // starts from 1
            x_space[col_ptr[ind]].value = x->value;
            col_ptr[ind]++;
            x++;
        }
    }
    for(i=0; i<n; i++)
        x_space[col_ptr[i]].index = -1;
    
    *x_space_ret = x_space;
    
    delete [] col_ptr;
}

// label: label name, start: begin of each class, count: #data of classes, perm: indices to the original data
// perm, length l, must be allocated before calling this subroutine
static void group_classes(const problem *prob, int *nr_class_ret, int **label_ret, int **start_ret, int **count_ret, int *perm)
{
    int l = prob->l;
    int max_nr_class = 16;
    int nr_class = 0;
    int *label = Malloc(int,max_nr_class);
    int *count = Malloc(int,max_nr_class);
    int *data_label = Malloc(int,l);
    int i;
    
    for(i=0;i<l;i++)
    {
        int this_label = (int)prob->y[i];
        int j;
        for(j=0;j<nr_class;j++)
        {
            if(this_label == label[j])
            {
                ++count[j];
                break;
            }
        }
        data_label[i] = j;
        if(j == nr_class)
        {
            if(nr_class == max_nr_class)
            {
                max_nr_class *= 2;
                label = (int *)realloc(label,max_nr_class*sizeof(int));
                count = (int *)realloc(count,max_nr_class*sizeof(int));
            }
            label[nr_class] = this_label;
            count[nr_class] = 1;
            ++nr_class;
        }
    }
    
    //
    // Labels are ordered by their first occurrence in the training set.
    // However, for two-class sets with -1/+1 labels and -1 appears first,
    // we swap labels to ensure that internally the binary SVM has positive data corresponding to the +1 instances.
    //
    if (nr_class == 2 && label[0] == -1 && label[1] == 1)
    {
        swap(label[0],label[1]);
        swap(count[0],count[1]);
        for(i=0;i<l;i++)
        {
            if(data_label[i] == 0)
                data_label[i] = 1;
            else
                data_label[i] = 0;
        }
    }
    
    int *start = Malloc(int,nr_class);
    start[0] = 0;
    for(i=1;i<nr_class;i++)
        start[i] = start[i-1]+count[i-1];
    for(i=0;i<l;i++)
    {
        perm[start[data_label[i]]] = i;
        ++start[data_label[i]];
    }
    start[0] = 0;
    for(i=1;i<nr_class;i++)
        start[i] = start[i-1]+count[i-1];
    
    *nr_class_ret = nr_class;
    *label_ret = label;
    *start_ret = start;
    *count_ret = count;
    free(data_label);
}

static void train_one(const problem *prob, const parameter *param, double *w, double Cp, double Cn)
{
    double eps=param->eps;
    int pos = 0;
    int neg = 0;
    for(int i=0;i<prob->l;i++)
        if(prob->y[i] > 0)
            pos++;
    neg = prob->l - pos;
    
    double primal_solver_tol = eps*max(min(pos,neg), 1)/prob->l;
    
    function *fun_obj=NULL;
    switch(param->solver_type)
    {
        case L2R_LR:
        {
            double *C = new double[prob->l];
            for(int i = 0; i < prob->l; i++)
            {
                if(prob->y[i] > 0)
                    C[i] = Cp;
                else
                    C[i] = Cn;
            }
            fun_obj=new l2r_lr_fun(prob, C);
            TRON tron_obj(fun_obj, primal_solver_tol);
            tron_obj.set_print_string(liblinear_print_string);
            tron_obj.tron(w);
            delete fun_obj;
            delete[] C;
            break;
        }
        case L2R_L2LOSS_SVC:
        {
            double *C = new double[prob->l];
            for(int i = 0; i < prob->l; i++)
            {
                if(prob->y[i] > 0)
                    C[i] = Cp;
                else
                    C[i] = Cn;
            }
            fun_obj=new l2r_l2_svc_fun(prob, C);
            TRON tron_obj(fun_obj, primal_solver_tol);
            tron_obj.set_print_string(liblinear_print_string);
            tron_obj.tron(w);
            delete fun_obj;
            delete[] C;
            break;
        }
        case L2R_L2LOSS_SVC_DUAL:
            solve_l2r_l1l2_svc(prob, w, eps, Cp, Cn, L2R_L2LOSS_SVC_DUAL);
            break;
        case L2R_L1LOSS_SVC_DUAL:
            solve_l2r_l1l2_svc(prob, w, eps, Cp, Cn, L2R_L1LOSS_SVC_DUAL);
            break;
        case L1R_L2LOSS_SVC:
        {
            problem prob_col;
            feature_node *x_space = NULL;
            transpose(prob, &x_space ,&prob_col);
            solve_l1r_l2_svc(&prob_col, w, primal_solver_tol, Cp, Cn);
            delete [] prob_col.y;
            delete [] prob_col.x;
            delete [] x_space;
            break;
        }
        case L1R_LR:
        {
            problem prob_col;
            feature_node *x_space = NULL;
            transpose(prob, &x_space ,&prob_col);
            solve_l1r_lr(&prob_col, w, primal_solver_tol, Cp, Cn);
            delete [] prob_col.y;
            delete [] prob_col.x;
            delete [] x_space;
            break;
        }
        case L2R_LR_DUAL:
            solve_l2r_lr_dual(prob, w, eps, Cp, Cn);
            break;
        case L2R_L2LOSS_SVR:
        {
            double *C = new double[prob->l];
            for(int i = 0; i < prob->l; i++)
                C[i] = param->C;
            
            fun_obj=new l2r_l2_svr_fun(prob, C, param->p);
            TRON tron_obj(fun_obj, param->eps);
            tron_obj.set_print_string(liblinear_print_string);
            tron_obj.tron(w);
            delete fun_obj;
            delete[] C;
            break;
            
        }
        case L2R_L1LOSS_SVR_DUAL:
            solve_l2r_l1l2_svr(prob, w, param, L2R_L1LOSS_SVR_DUAL);
            break;
        case L2R_L2LOSS_SVR_DUAL:
            solve_l2r_l1l2_svr(prob, w, param, L2R_L2LOSS_SVR_DUAL);
            break;
        default:
            fprintf(stderr, "ERROR: unknown solver_type\n");
            break;
    }
}

//
// Interface functions
//
model* train(const problem *prob, const parameter *param)
{
    int i,j;
    int l = prob->l;
    int n = prob->n;
    int w_size = prob->n;
    model *model_ = Malloc(model,1);
    
    if(prob->bias>=0)
        model_->nr_feature=n-1;
    else
        model_->nr_feature=n;
    model_->param = *param;
    model_->bias = prob->bias;
    
    if(check_regression_model(model_))
    {
        model_->w = Malloc(double, w_size);
        model_->nr_class = 2;
        model_->label = NULL;
        train_one(prob, param, &model_->w[0], 0, 0);
    }
    else
    {
        int nr_class;
        int *label = NULL;
        int *start = NULL;
        int *count = NULL;
        int *perm = Malloc(int,l);
        
        // group training data of the same class
        group_classes(prob,&nr_class,&label,&start,&count,perm);
        
        model_->nr_class=nr_class;
        model_->label = Malloc(int,nr_class);
        for(i=0;i<nr_class;i++)
            model_->label[i] = label[i];
        
        // calculate weighted C
        double *weighted_C = Malloc(double, nr_class);
        for(i=0;i<nr_class;i++)
            weighted_C[i] = param->C;
        for(i=0;i<param->nr_weight;i++)
        {
            for(j=0;j<nr_class;j++)
                if(param->weight_label[i] == label[j])
                    break;
            if(j == nr_class)
                fprintf(stderr,"WARNING: class label %d specified in weight is not found\n", param->weight_label[i]);
            else
                weighted_C[j] *= param->weight[i];
        }
        
        // constructing the subproblem
        feature_node **x = Malloc(feature_node *,l);
        for(i=0;i<l;i++)
            x[i] = prob->x[perm[i]];
        
        int k;
        problem sub_prob;
        sub_prob.l = l;
        sub_prob.n = n;
        sub_prob.x = Malloc(feature_node *,sub_prob.l);
        sub_prob.y = Malloc(double,sub_prob.l);
        
        for(k=0; k<sub_prob.l; k++)
            sub_prob.x[k] = x[k];
        
        // multi-class svm by Crammer and Singer
        if(param->solver_type == MCSVM_CS)
        {
            model_->w=Malloc(double, n*nr_class);
            for(i=0;i<nr_class;i++)
                for(j=start[i];j<start[i]+count[i];j++)
                    sub_prob.y[j] = i;
            Solver_MCSVM_CS Solver(&sub_prob, nr_class, weighted_C, param->eps);
            Solver.Solve(model_->w);
        }
        else
        {
            if(nr_class == 2)
            {
                model_->w=Malloc(double, w_size);
                
                int e0 = start[0]+count[0];
                k=0;
                for(; k<e0; k++)
                    sub_prob.y[k] = +1;
                for(; k<sub_prob.l; k++)
                    sub_prob.y[k] = -1;
                
                train_one(&sub_prob, param, &model_->w[0], weighted_C[0], weighted_C[1]);
            }
            else
            {
                model_->w=Malloc(double, w_size*nr_class);
                double *w=Malloc(double, w_size);
                for(i=0;i<nr_class;i++)
                {
                    int si = start[i];
                    int ei = si+count[i];
                    
                    k=0;
                    for(; k<si; k++)
                        sub_prob.y[k] = -1;
                    for(; k<ei; k++)
                        sub_prob.y[k] = +1;
                    for(; k<sub_prob.l; k++)
                        sub_prob.y[k] = -1;
                    
                    train_one(&sub_prob, param, w, weighted_C[i], param->C);
                    
                    for(int j=0;j<w_size;j++)
                        model_->w[j*nr_class+i] = w[j];
                }
                free(w);
            }
            
        }
        
        free(x);
        free(label);
        free(start);
        free(count);
        free(perm);
        free(sub_prob.x);
        free(sub_prob.y);
        free(weighted_C);
    }
    return model_;
}

void cross_validation(const problem *prob, const parameter *param, int nr_fold, double *target)
{
    int i;
    int *fold_start;
    int l = prob->l;
    int *perm = Malloc(int,l);
    if (nr_fold > l)
    {
        nr_fold = l;
        fprintf(stderr,"WARNING: # folds > # data. Will use # folds = # data instead (i.e., leave-one-out cross validation)\n");
    }
    fold_start = Malloc(int,nr_fold+1);
    for(i=0;i<l;i++) perm[i]=i;
    for(i=0;i<l;i++)
    {
        int j = i+rand()%(l-i);
        swap(perm[i],perm[j]);
    }
    for(i=0;i<=nr_fold;i++)
        fold_start[i]=i*l/nr_fold;
    
    for(i=0;i<nr_fold;i++)
    {
        int begin = fold_start[i];
        int end = fold_start[i+1];
        int j,k;
        struct problem subprob;
        
        subprob.bias = prob->bias;
        subprob.n = prob->n;
        subprob.l = l-(end-begin);
        subprob.x = Malloc(struct feature_node*,subprob.l);
        subprob.y = Malloc(double,subprob.l);
        
        k=0;
        for(j=0;j<begin;j++)
        {
            subprob.x[k] = prob->x[perm[j]];
            subprob.y[k] = prob->y[perm[j]];
            ++k;
        }
        for(j=end;j<l;j++)
        {
            subprob.x[k] = prob->x[perm[j]];
            subprob.y[k] = prob->y[perm[j]];
            ++k;
        }
        struct model *submodel = train(&subprob,param);
        for(j=begin;j<end;j++)
            target[perm[j]] = predict(submodel,prob->x[perm[j]]);
        free_and_destroy_model(&submodel);
        free(subprob.x);
        free(subprob.y);
    }
    free(fold_start);
    free(perm);
}

double predict_values(const struct model *model_, const struct feature_node *x, double *dec_values)
{
    int idx;
    int n;
    if(model_->bias>=0)
        n=model_->nr_feature+1;
    else
        n=model_->nr_feature;
    double *w=model_->w;
    int nr_class=model_->nr_class;
    int i;
    int nr_w;
    if(nr_class==2 && model_->param.solver_type != MCSVM_CS)
        nr_w = 1;
    else
        nr_w = nr_class;
    
    const feature_node *lx=x;
    for(i=0;i<nr_w;i++)
        dec_values[i] = 0;
    for(; (idx=lx->index)!=-1; lx++)
    {
        // the dimension of testing data may exceed that of training
        if(idx<=n)
            for(i=0;i<nr_w;i++)
                dec_values[i] += w[(idx-1)*nr_w+i]*lx->value;
    }
    
    if(nr_class==2)
    {
        if(check_regression_model(model_))
            return dec_values[0];
        else
            return (dec_values[0]>0)?model_->label[0]:model_->label[1];
    }
    else
    {
        int dec_max_idx = 0;
        for(i=1;i<nr_class;i++)
        {
            if(dec_values[i] > dec_values[dec_max_idx])
                dec_max_idx = i;
        }
        return model_->label[dec_max_idx];
    }
}

double predict(const model *model_, const feature_node *x)
{
    double *dec_values = Malloc(double, model_->nr_class);
    double label=predict_values(model_, x, dec_values);
    free(dec_values);
    return label;
}

double predict_probability(const struct model *model_, const struct feature_node *x, double* prob_estimates)
{
    if(check_probability_model(model_))
    {
        int i;
        int nr_class=model_->nr_class;
        int nr_w;
        if(nr_class==2)
            nr_w = 1;
        else
            nr_w = nr_class;
        
        double label=predict_values(model_, x, prob_estimates);
        for(i=0;i<nr_w;i++)
            prob_estimates[i]=1/(1+exp(-prob_estimates[i]));
        
        if(nr_class==2) // for binary classification
            prob_estimates[1]=1.-prob_estimates[0];
        else
        {
            double sum=0;
            for(i=0; i<nr_class; i++)
                sum+=prob_estimates[i];
            
            for(i=0; i<nr_class; i++)
                prob_estimates[i]=prob_estimates[i]/sum;
        }
        
        return label;
    }
    else
        return 0;
}

static const char *solver_type_table[]=
{
    "L2R_LR", "L2R_L2LOSS_SVC_DUAL", "L2R_L2LOSS_SVC", "L2R_L1LOSS_SVC_DUAL", "MCSVM_CS",
    "L1R_L2LOSS_SVC", "L1R_LR", "L2R_LR_DUAL",
    "", "", "",
    "L2R_L2LOSS_SVR", "L2R_L2LOSS_SVR_DUAL", "L2R_L1LOSS_SVR_DUAL", NULL
};

int save_model(const char *model_file_name, const struct model *model_)
{
    int i;
    int nr_feature=model_->nr_feature;
    int n;
    const parameter& param = model_->param;
    
    if(model_->bias>=0)
        n=nr_feature+1;
    else
        n=nr_feature;
    int w_size = n;
    FILE *fp = fopen(model_file_name,"w");
    if(fp==NULL) return -1;
    
    char *old_locale = strdup(setlocale(LC_ALL, NULL));
    setlocale(LC_ALL, "C");
    
    int nr_w;
    if(model_->nr_class==2 && model_->param.solver_type != MCSVM_CS)
        nr_w=1;
    else
        nr_w=model_->nr_class;
    
    fprintf(fp, "solver_type %s\n", solver_type_table[param.solver_type]);
    fprintf(fp, "nr_class %d\n", model_->nr_class);
    
    if(model_->label)
    {
        fprintf(fp, "label");
        for(i=0; i<model_->nr_class; i++)
            fprintf(fp, " %d", model_->label[i]);
        fprintf(fp, "\n");
    }
    
    fprintf(fp, "nr_feature %d\n", nr_feature);
    
    fprintf(fp, "bias %.16g\n", model_->bias);
    
    fprintf(fp, "w\n");
    for(i=0; i<w_size; i++)
    {
        int j;
        for(j=0; j<nr_w; j++)
            fprintf(fp, "%.16g ", model_->w[i*nr_w+j]);
        fprintf(fp, "\n");
    }
    
    setlocale(LC_ALL, old_locale);
    free(old_locale);
    
    if (ferror(fp) != 0 || fclose(fp) != 0) return -1;
    else return 0;
}

struct model *load_model(const char *model_file_name)
{
    FILE *fp = fopen(model_file_name,"r");
    if(fp==NULL) return NULL;
    
    int i;
    int nr_feature;
    int n;
    int nr_class;
    double bias;
    model *model_ = Malloc(model,1);
    parameter& param = model_->param;
    
    model_->label = NULL;
    
    char *old_locale = strdup(setlocale(LC_ALL, NULL));
    setlocale(LC_ALL, "C");
    
    char cmd[81];
    while(1)
    {
        fscanf(fp,"%80s",cmd);
        if(strcmp(cmd,"solver_type")==0)
        {
            fscanf(fp,"%80s",cmd);
            int i;
            for(i=0;solver_type_table[i];i++)
            {
                if(strcmp(solver_type_table[i],cmd)==0)
                {
                    param.solver_type=i;
                    break;
                }
            }
            if(solver_type_table[i] == NULL)
            {
                fprintf(stderr,"unknown solver type.\n");
                
                setlocale(LC_ALL, old_locale);
                free(model_->label);
                free(model_);
                free(old_locale);
                return NULL;
            }
        }
        else if(strcmp(cmd,"nr_class")==0)
        {
            fscanf(fp,"%d",&nr_class);
            model_->nr_class=nr_class;
        }
        else if(strcmp(cmd,"nr_feature")==0)
        {
            fscanf(fp,"%d",&nr_feature);
            model_->nr_feature=nr_feature;
        }
        else if(strcmp(cmd,"bias")==0)
        {
            fscanf(fp,"%lf",&bias);
            model_->bias=bias;
        }
        else if(strcmp(cmd,"w")==0)
        {
            break;
        }
        else if(strcmp(cmd,"label")==0)
        {
            int nr_class = model_->nr_class;
            model_->label = Malloc(int,nr_class);
            for(int i=0;i<nr_class;i++)
                fscanf(fp,"%d",&model_->label[i]);
        }
        else
        {
            fprintf(stderr,"unknown text in model file: [%s]\n",cmd);
            setlocale(LC_ALL, old_locale);
            free(model_->label);
            free(model_);
            free(old_locale);
            return NULL;
        }
    }
    
    nr_feature=model_->nr_feature;
    if(model_->bias>=0)
        n=nr_feature+1;
    else
        n=nr_feature;
    int w_size = n;
    int nr_w;
    if(nr_class==2 && param.solver_type != MCSVM_CS)
        nr_w = 1;
    else
        nr_w = nr_class;
    
    model_->w=Malloc(double, w_size*nr_w);
    for(i=0; i<w_size; i++)
    {
        int j;
        for(j=0; j<nr_w; j++)
            fscanf(fp, "%lf ", &model_->w[i*nr_w+j]);
        fscanf(fp, "\n");
    }
    
    setlocale(LC_ALL, old_locale);
    free(old_locale);
    
    if (ferror(fp) != 0 || fclose(fp) != 0) return NULL;
    
    return model_;
}
/* my own save and load model*/
int save_model_bin(std::ofstream& fout, const struct model *model_)
{
    int nr_feature=model_->nr_feature;
    int n;
    const parameter& param = model_->param;
    
    if(model_->bias>=0)
        n=nr_feature+1;
    else
        n=nr_feature;
    int w_size = n;
    
    char *old_locale = strdup(setlocale(LC_ALL, NULL));
    setlocale(LC_ALL, "C");
    
    int nr_w;
    if(model_->nr_class==2 && model_->param.solver_type != MCSVM_CS)
        nr_w=1;
    else
        nr_w=model_->nr_class;
    
//    fprintf(fp, "solver_type %s\n", solver_type_table[param.solver_type]);
//    fprintf(fp, "nr_class %d\n", model_->nr_class);
    fout.write((char*)&param.solver_type, sizeof(int));
    fout.write((char*)&model_->nr_class, sizeof(int));
  
    int haslabel = 0;
    if (model_->label) {
        haslabel = 1;
    }
    else{
        haslabel = 0;
    }
    fout.write((char*)&haslabel, sizeof(int));
    if(model_->label)
    {
//        fprintf(fp, "label");
//        for(i=0; i<model_->nr_class; i++)
//            fprintf(fp, " %d", model_->label[i]);
//        fprintf(fp, "\n");
        fout.write((char*)model_->label, sizeof(int)*model_->nr_class);
    }
    
//    fprintf(fp, "nr_feature %d\n", nr_feature);
//    
//    fprintf(fp, "bias %.16g\n", model_->bias);
//    
//    fprintf(fp, "w\n");
    
//    for(i=0; i<w_size; i++)
//    {
//        int j;
//        for(j=0; j<nr_w; j++)
//            fprintf(fp, "%.16g ", model_->w[i*nr_w+j]);
//        fprintf(fp, "\n");
//    }
    
    fout.write((char*)&nr_feature, sizeof(int));
    fout.write((char*)&model_->bias, sizeof(double));
    fout.write((char*)model_->w, sizeof(double)*w_size*nr_w);
    
    setlocale(LC_ALL, old_locale);
    free(old_locale);
    
    return 0;
}

struct model *load_model_bin(std::ifstream& fin)
{
    int nr_feature;
    int n;
    int nr_class;
    int haslabel;
    model *model_ = Malloc(model,1);
    parameter& param = model_->param;
    
    model_->label = NULL;
    
    char *old_locale = strdup(setlocale(LC_ALL, NULL));
    setlocale(LC_ALL, "C");
  
    fin.read((char*)&param.solver_type, sizeof(int));
    fin.read((char*)&model_->nr_class, sizeof(int));
    nr_class = model_->nr_class;
    fin.read((char*)&haslabel, sizeof(int));
    if (haslabel){
        fin.read((char*)model_->label, sizeof(int)*model_->nr_class);

    }
    fin.read((char*)&model_->nr_feature, sizeof(int));
    fin.read((char*)&model_->bias, sizeof(double));

    nr_feature=model_->nr_feature;
    if(model_->bias>=0)
        n=nr_feature+1;
    else
        n=nr_feature;
    int w_size = n;
    int nr_w;
    if(nr_class==2 && param.solver_type != MCSVM_CS)
        nr_w = 1;
    else
        nr_w = nr_class;
    
    model_->w=Malloc(double, w_size*nr_w);
//    for(i=0; i<w_size; i++)
//    {
//        int j;
//        for(j=0; j<nr_w; j++)
//            fscanf(fp, "%lf ", &model_->w[i*nr_w+j]);
//        fscanf(fp, "\n");
//    }
    
    fin.read((char*)model_->w, sizeof(double)*w_size*nr_w);
    
    double * dd = model_->w;
    for(int i=0;i<w_size*nr_w;i++) {
        float f = (float)dd[i];                 //64bit to 32bit
        uint16_t h = 0;
        ccv_float_to_half_precision(&f,&h,1);   //32bit to 16bit
        h = h >> 8;                             //16bit to 8bit, result: 8bit good, 6bit good, 4bit bad
        h = h << 8;
        ccv_half_precision_to_float(&h,&f,1);
        dd[i] = (double)f;
    }
    
    setlocale(LC_ALL, old_locale);
    free(old_locale);
    return model_;
}

/*****************************/
int get_nr_feature(const model *model_)
{
    return model_->nr_feature;
}

int get_nr_class(const model *model_)
{
    return model_->nr_class;
}

void get_labels(const model *model_, int* label)
{
    if (model_->label != NULL)
        for(int i=0;i<model_->nr_class;i++)
            label[i] = model_->label[i];
}

// use inline here for better performance (around 20% faster than the non-inline one)
static inline double get_w_value(const struct model *model_, int idx, int label_idx) 
{
    int nr_class = model_->nr_class;
    int solver_type = model_->param.solver_type;
    const double *w = model_->w;
    
    if(idx < 0 || idx > model_->nr_feature)
        return 0;
    if(check_regression_model(model_))
        return w[idx];
    else 
    {
        if(label_idx < 0 || label_idx >= nr_class)
            return 0;
        if(nr_class == 2 && solver_type != MCSVM_CS)
        {
            if(label_idx == 0)
                return w[idx];
            else
                return -w[idx];
        }
        else
            return w[idx*nr_class+label_idx];
    }
}

// feat_idx: starting from 1 to nr_feature
// label_idx: starting from 0 to nr_class-1 for classification models;
//            for regression models, label_idx is ignored.
double get_decfun_coef(const struct model *model_, int feat_idx, int label_idx)
{
    if(feat_idx > model_->nr_feature)
        return 0;
    return get_w_value(model_, feat_idx-1, label_idx);
}

double get_decfun_bias(const struct model *model_, int label_idx)
{
    int bias_idx = model_->nr_feature;
    double bias = model_->bias;
    if(bias <= 0)
        return 0;
    else
        return bias*get_w_value(model_, bias_idx, label_idx);
}

void free_model_content(struct model *model_ptr)
{
    if(model_ptr->w != NULL)
        free(model_ptr->w);
    if(model_ptr->label != NULL)
        free(model_ptr->label);
}

void free_and_destroy_model(struct model **model_ptr_ptr)
{
    struct model *model_ptr = *model_ptr_ptr;
    if(model_ptr != NULL)
    {
        free_model_content(model_ptr);
        free(model_ptr);
    }
}

void destroy_param(parameter* param)
{
    if(param->weight_label != NULL)
        free(param->weight_label);
    if(param->weight != NULL)
        free(param->weight);
}

const char *check_parameter(const problem *prob, const parameter *param)
{
    if(param->eps <= 0)
        return "eps <= 0";
    
    if(param->C <= 0)
        return "C <= 0";
    
    if(param->p < 0)
        return "p < 0";
    
    if(param->solver_type != L2R_LR
       && param->solver_type != L2R_L2LOSS_SVC_DUAL
       && param->solver_type != L2R_L2LOSS_SVC
       && param->solver_type != L2R_L1LOSS_SVC_DUAL
       && param->solver_type != MCSVM_CS
       && param->solver_type != L1R_L2LOSS_SVC
       && param->solver_type != L1R_LR
       && param->solver_type != L2R_LR_DUAL
       && param->solver_type != L2R_L2LOSS_SVR
       && param->solver_type != L2R_L2LOSS_SVR_DUAL
       && param->solver_type != L2R_L1LOSS_SVR_DUAL)
        return "unknown solver type";
    
    return NULL;
}

int check_probability_model(const struct model *model_)
{
    return (model_->param.solver_type==L2R_LR ||
            model_->param.solver_type==L2R_LR_DUAL ||
            model_->param.solver_type==L1R_LR);
}

int check_regression_model(const struct model *model_)
{
    return (model_->param.solver_type==L2R_L2LOSS_SVR ||
            model_->param.solver_type==L2R_L1LOSS_SVR_DUAL ||
            model_->param.solver_type==L2R_L2LOSS_SVR_DUAL);
}

void set_print_string_function(void (*print_func)(const char*))
{
    if (print_func == NULL)
        liblinear_print_string = &print_string_stdout;
    else
        liblinear_print_string = print_func;
}
